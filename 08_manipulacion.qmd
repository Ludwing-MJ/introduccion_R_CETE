# Manipulación de datos con dplyr y tidyr

```{r message=FALSE, warning=FALSE, echo=FALSE}
# Instalar y cargar el tidyverse
if (!require("tidyverse")) install.packages("tidyverse")
```

Los paquetes **dplyr** y **tidyr** son componentes fundamentales del ecosistema **tidyverse**, diseñados para simplificar y optimizar la manipulación y transformación de datos en R. Estas herramientas permiten realizar tareas comunes de análisis de datos de manera eficiente, reproducible y con una sintaxis clara e intuitiva (Wickham et al., 2023). En esta sección, se explorarán las principales funciones de estos paquetes, junto con ejemplos prácticos que ilustran su uso.

## Introducción a los paquetes `dplyr` y `tidyr`

El paquete **dplyr** está especializado en la manipulación de datos tabulares, ofreciendo funciones específicas para realizar operaciones como filtrar filas, seleccionar columnas, crear nuevas variables y resumir datos. Su diseño está optimizado para trabajar con estructuras como data frames y tibbles, proporcionando un rendimiento superior y una sintaxis más legible en comparación con las funciones base de R.

Por otro lado, el paquete **tidyr** se centra en la reorganización de datos, facilitando la transformación entre formatos "ancho" y "largo". Estas transformaciones son esenciales para preparar los datos de manera adecuada antes de su análisis o visualización, asegurando que estén en el formato más conveniente para las herramientas de análisis.

Para ilustrar el uso de estas herramientas, en esta sección se desarrollará un ejemplo práctico que permitirá explorar las principales funciones de manipulación de datos. El script correspondiente a este ejemplo está disponible en el siguiente repositorio: [Repositorio de ejemplo - Manipulación de datos](https://github.com/Ludwing-MJ/Manipulacion_Ej).

## Operaciones básicas con dplyr

### Filtrar filas con `filter()`

La función **`filter()`** se utiliza para seleccionar filas de un *data frame* que cumplen con una o más condiciones lógicas. Esta operación es útil para extraer subconjuntos de datos relevantes para un análisis específico.

**Sintaxis básica:**

```{r eval=FALSE}
filter(data, condición)
```

**Ejemplo práctico:** Filtrar estudiantes con un peso mayor a 65 kg.

```{r message=FALSE, warning=FALSE}

# Crear un data frame de ejemplo
datos <- data.frame(
  nombre = c("Juan", "Ana", "Luis", "María"),
  edad = c(18, 22, 20, 19),
  peso = c(70, 55, 80, 60),
  altura = c(1.75, 1.60, 1.80, 1.65)
)

# Filtrar estudiantes con peso mayor a 65 kg
estudiantes_pesados <- datos %>% 
  filter(peso > 65)

# Visualizar el resultado
estudiantes_pesados
```

**Explicación**: El resultado es un *data frame* que incluye únicamente las filas donde la variable `peso` es mayor a 65. Esta operación permite enfocar el análisis en un subconjunto específico de datos, lo que resulta útil en estudios que requieren segmentación de información.

### Seleccionar columnas con `select()`

La función **`select()`** permite extraer columnas específicas de un *data frame*. Esto es útil para reducir la cantidad de datos visibles o para trabajar únicamente con las variables necesarias.

**Sintaxis básica:**

```{r eval=FALSE}
select(data, columnas)
```

**Ejemplo práctico:** Seleccionar las columnas `nombre` y `edad`.

```{r}
# Seleccionar columnas específicas
datos_reducidos <- datos %>%
  select(nombre, edad)

# Visualizar el resultado
datos_reducidos
```

**Explicación**: El resultado es un *data frame* que contiene únicamente las columnas `nombre` y `edad`. Esto es especialmente útil cuando se desea exportar información específica o simplificar la visualización de los datos.

### **Crear nuevas columnas con `mutate()`**

La función **`mutate()`** permite añadir nuevas columnas calculadas a un *data frame*. Esta operación es esencial para realizar cálculos derivados de las variables existentes.

**Sintaxis básica:**

```{r eval=FALSE}
mutate(data, nueva_columna = expresión)
```

**Ejemplo práctico:** Calcular el índice de masa corporal (IMC) de los estudiantes.

```{r}
# Calcular el IMC
datos <- datos %>%
  mutate(IMC = peso / (altura^2))

# Visualizar el resultado
datos
```

**Explicación**: Se añade una nueva columna llamada `IMC` al *data frame*, calculada como el peso dividido por el cuadrado de la altura. Esta operación permite enriquecer los datos con información derivada, facilitando análisis más detallados.

### Agrupar y resumir datos con `group_by()` y `summarize()`

La combinación de **`group_by()`** y **`summarize()`** permite calcular estadísticas por grupo. Esto es útil para obtener resúmenes de datos categorizados, como promedios, sumas o conteos.

**Sintaxis básica**:

```{r eval=FALSE}
  data %>%
  group_by(grupo) %>%
  summarize(resumen = función(variable))
```

**Ejemplo práctico**: Calcular el peso promedio por grupo de edad (mayores y menores de 20 años).

```{r}
# Calcular peso promedio por grupo de edad
peso_promedio <- datos %>%
  mutate(grupo_edad = ifelse(edad >= 20, 
                             "Mayor o igual a 20", 
                             "Menor a 20")) %>%
  group_by(grupo_edad) %>%
  summarize(peso_promedio = mean(peso))

# Visualizar el resultado
peso_promedio
```

**Explicación**: Se crea una nueva variable `grupo_edad` que clasifica a los estudiantes en dos categorías: "Mayor o igual a 20" y "Menor a 20". Luego, se calcula el peso promedio para cada grupo. Este tipo de operación es útil para realizar análisis comparativos entre categorías, como estudios demográficos o segmentación de datos.

## Uso de pipes (`%>%`) para mejorar la legibilidad del código

El operador **pipe** (`%>%`), introducido por el paquete `magrittr` y ampliamente adoptado en el ecosistema tidyverse, permite encadenar funciones de manera legible. En lugar de anidar funciones, el pipe pasa el resultado de una función como entrada a la siguiente.

**Ejemplo sin pipes**: Cuando no se utiliza el operador pipe, las funciones deben anidarse o ejecutarse en pasos separados, lo que puede dificultar la lectura y comprensión del código:

```{r}
# Crear columna grupo_edad usando mutate
datos <- datos %>%
  mutate(grupo_edad = ifelse(edad >= 20, 
                             "Mayor o igual a 20", 
                             "Menor a 20")) 
# Agrupar y resumir los datos sin pipes
resultado <- summarize(group_by(datos, grupo_edad),
                       peso_promedio = mean(peso))
```

**Ejemplo con pipes**: El uso de pipes permite encadenar las operaciones de manera más clara y natural, eliminando la necesidad de anidar funciones:

```{r}
# Agrupar y resumir los datos con pipes
resultado <- datos %>%   
  group_by(grupo_edad) %>%   
  summarize(peso_promedio = mean(peso))
```

**Diferencia clave**: Con pipes, el flujo de trabajo se lee de arriba hacia abajo, siguiendo un orden lógico que refleja el proceso de análisis.

### Ventajas del uso de pipes

El uso de pipes (`%>%`) en R mejora significativamente la **legibilidad** del código al permitir que las operaciones se encadenen de manera secuencial y lógica, eliminando la necesidad de anidar funciones. Esto facilita la comprensión del flujo de trabajo, especialmente en análisis complejos. Además, los pipes simplifican la **depuración**, ya que dividen el análisis en pasos claros, lo que permite identificar errores y verificar resultados intermedios con mayor facilidad.

Otra ventaja clave es la **modularidad**, ya que cada operación se organiza como un bloque independiente, lo que facilita realizar ajustes sin afectar el resto del análisis. Finalmente, los pipes promueven la **reproducibilidad**, al estructurar el código de forma clara y reutilizable, mejorando la colaboración y asegurando resultados consistentes.

## Transformación de datos con tidyr

El paquete **`tidyr`** es una herramienta fundamental para la reorganización de datos en R, especialmente cuando se necesita cambiar entre formatos "ancho" y "largo". Esta transformación es esencial para adaptar los datos a diferentes tipos de análisis estadísticos y visualizaciones (Wickham & Grolemund, 2017).

### ¿Qué son los formatos ancho y largo?

**Formato ancho**: Cada variable tiene su propia columna, y cada observación está en una sola fila.

**Formato largo**: Las variables están organizadas en pares de columnas (nombre de variable y valor), con múltiples filas por observación.

### Funciones principales de transformación

1.  **`pivot_longer()`**: se utiliza para transformar datos de formato ancho a largo. Este tipo de transformación es especialmente útil cuando se necesita trabajar con datos en los que cada observación debe ocupar una fila, mientras que las variables se representan en columnas separadas. Por ejemplo, es ideal para crear gráficos con múltiples series, ya que facilita la comparación entre diferentes variables en un mismo análisis. Además, este formato es requerido en muchos análisis estadísticos que trabajan con datos agrupados, como ANOVA o modelos de regresión, donde las variables deben estar organizadas en un formato más estructurado.

2.  **`pivot_wider()`**: realiza la transformación inversa, es decir, convierte datos de formato largo a ancho. Este tipo de transformación es útil cuando se necesita crear tablas resumen que presenten los datos de manera más compacta y legible. También es esencial para análisis que requieren que las variables estén en columnas separadas, como cálculos de correlación o regresiones específicas. Además, el formato ancho es más adecuado para la presentación de resultados en reportes o tablas, ya que permite visualizar de forma clara las relaciones entre las variables y las observaciones.

### Ejemplo práctico

Para ilustrar el uso de las funciones de transformación de datos, consideremos un ejemplo práctico con calificaciones de estudiantes. Inicialmente, crearemos un conjunto de datos que contiene las calificaciones de tres estudiantes en dos materias diferentes:

```{r}
# Crear data frame de calificaciones
calificaciones <- data.frame(
  nombre = c("Juan", "Ana", "Luis"),
  matematicas = c(85, 90, 78),
  ciencias = c(88, 92, 80)
)

# Visualizar el data frame original
print("Datos originales en formato ancho:")
calificaciones

```

En este formato, cada fila representa a un estudiante y las calificaciones de las materias están organizadas en columnas. Sin embargo, para ciertos análisis estadísticos o visualizaciones, es necesario transformar los datos a un formato largo.

#### **Transformar de formato ancho a largo**

La función `pivot_longer()` permite reorganizar los datos para que cada combinación de estudiante y materia ocupe una fila independiente. Este formato es útil para análisis que requieren datos agrupados o para la creación de gráficos comparativos:

```{r}
# Transformar a formato largo
calificaciones_largo <- calificaciones %>%
  pivot_longer(
    cols = c(matematicas, ciencias),    # Columnas a transformar
    names_to = "materia",               # Nueva columna para nombres de materias
    values_to = "calificacion"          # Nueva columna para calificaciones
  )

print("Datos en formato largo:")
calificaciones_largo
```

En este formato, cada fila representa una observación única de estudiante y materia, lo que facilita la comparación entre variables, el cálculo de estadísticas por grupo y la preparación de datos para visualizaciones.

#### Transformar de formato largo a ancho

Cuando se requiere regresar al formato original, por ejemplo, para presentar los datos en una tabla resumen, se utiliza la función `pivot_wider()`. Esta función reorganiza los datos para que las materias vuelvan a ocupar columnas separadas:

```{r}
# Transformar de vuelta a formato ancho
calificaciones_ancho <- calificaciones_largo %>%
  pivot_wider(
    names_from = "materia",            # Columna que se convertirá en nombres de columnas
    values_from = "calificacion"       # Columna que contiene los valores
  )

print("Datos restaurados en formato ancho:")
calificaciones_ancho

```

Esta transformación permite restaurar el formato original, donde cada estudiante ocupa una fila y las materias están organizadas en columnas. Este formato es adecuado para reportes, análisis que requieren variables en columnas independientes o para la presentación de datos de manera más legible.
