[
  {
    "objectID": "07_paquetes.html",
    "href": "07_paquetes.html",
    "title": "8  Paquetes en R",
    "section": "",
    "text": "8.1 ¿Qué es un paquete en R?\nLos paquetes en R son una de las características más poderosas del lenguaje, ya que permiten extender sus capacidades básicas para realizar tareas específicas de manera eficiente. Estos paquetes son fundamentales para el análisis estadístico y la manipulación de datos, ya que proporcionan herramientas especializadas desarrolladas por expertos en diferentes campos (R Core Team, 2023).\nUn paquete en R es una colección organizada de funciones, datos y documentación que amplía las capacidades del entorno base de R. Estos paquetes son desarrollados por la comunidad de usuarios y están diseñados para resolver problemas específicos, desde la manipulación de datos hasta la visualización avanzada o el análisis estadístico especializado (Wickham & Bryan, 2023).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Paquetes en R</span>"
    ]
  },
  {
    "objectID": "07_paquetes.html#qué-es-un-paquete-en-r",
    "href": "07_paquetes.html#qué-es-un-paquete-en-r",
    "title": "8  Paquetes en R",
    "section": "",
    "text": "8.1.1 Características principales de los paquetes\n\nFunciones especializadas: Cada paquete incluye funciones diseñadas para tareas específicas, como crear gráficos, realizar análisis estadísticos o manipular datos.\nDocumentación: Los paquetes incluyen documentación detallada que explica cómo utilizarlos, con ejemplos prácticos.\nDatos de ejemplo: Muchos paquetes incluyen conjuntos de datos que permiten practicar y entender su funcionalidad.\n\n\n\n8.1.2 ¿Por qué usar paquetes en R?\nLos paquetes son esenciales para aprovechar al máximo el potencial de R por varias razones (Wickham & Grolemund, 2017):\n\nExtensibilidad: Permiten realizar tareas que no están disponibles en el entorno base de R.\nEficiencia: Simplifican procesos complejos, reduciendo el tiempo necesario para realizar análisis.\nEspecialización: Existen paquetes diseñados para áreas específicas, como la agronomía (agricolae), la biología (vegan) o la economía (forecast).\nComunidad activa: La comunidad de R desarrolla y mantiene una amplia variedad de paquetes, lo que garantiza su actualización y soporte.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Paquetes en R</span>"
    ]
  },
  {
    "objectID": "07_paquetes.html#instalación-y-carga-de-paquetes",
    "href": "07_paquetes.html#instalación-y-carga-de-paquetes",
    "title": "8  Paquetes en R",
    "section": "8.2 Instalación y carga de paquetes",
    "text": "8.2 Instalación y carga de paquetes\nLa instalación de paquetes en R se realiza principalmente desde CRAN (Comprehensive R Archive Network), el repositorio oficial que alberga más de 19,000 paquetes. Para instalar un paquete, se utiliza la función install.packages().\n\n8.2.1 Proceso de instalación\n\n# Instalación del paquete ggplot2\ninstall.packages(\"ggplot2\")\n\n\n\n8.2.2 Carga de paquetes\nUna vez instalado, un paquete debe cargarse en la sesión actual para poder utilizar sus funciones. Esto se realiza con la función library().\n\n# Cargar el paquete ggplot2\nlibrary(ggplot2)\n\nEs importante destacar que la instalación de un paquete solo se realiza una vez, pero debe cargarse en cada nueva sesión de trabajo.\n\n\n8.2.3 Automatización de la instalación y carga\nPara garantizar que un paquete esté disponible en el entorno de trabajo, se puede utilizar la siguiente “receta mágica”, que verifica si el paquete está instalado y, en caso contrario, lo instala y carga al entorno de trabajo automáticamente:\n\n# Verificar e instalar automáticamente un paquete\nif (!require(\"ggplot2\")) install.packages(\"ggplot2\")\n\nEsta estructura es útil para mantener el código reproducible y evitar errores al compartir scripts con otros usuarios.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Paquetes en R</span>"
    ]
  },
  {
    "objectID": "07_paquetes.html#paquetes-recomendados-para-tareas-específicas",
    "href": "07_paquetes.html#paquetes-recomendados-para-tareas-específicas",
    "title": "8  Paquetes en R",
    "section": "8.3 Paquetes recomendados para tareas específicas",
    "text": "8.3 Paquetes recomendados para tareas específicas\nEn el contexto del análisis estadístico, algunos paquetes son especialmente útiles. A continuación, se presenta una lista de paquetes recomendados, junto con una breve descripción de su funcionalidad:\n\n8.3.1 Manipulación de datos\n\ndplyr: Simplifica la manipulación de datos mediante funciones intuitivas para filtrar, seleccionar y resumir datos.\ntidyr: Facilita la transformación de datos entre formatos ancho y largo.\n\n\n\n8.3.2 Visualización de datos\n\nggplot2: Permite crear gráficos personalizados y de alta calidad basados en la gramática de gráficos.\n\n\n\n8.3.3 Análisis estadístico\n\nstats: Incluye funciones base para realizar pruebas t, ANOVA y regresiones.\nagricolae: Diseñado para análisis estadísticos en agronomía, como diseños experimentales y pruebas de comparación múltiple.\n\n\n\n8.3.4 Ejemplo práctico: Instalación y carga de paquetes esenciales\n\n# Instalación y carga de paquetes esenciales\n\n# tidyverse (incluye ggplot2, dplyr, tidyr)\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Diseños experimentales agrícolas\nif (!require(\"agricolae\")) install.packages(\"agricolae\")\n\n# Manejo de archivos Excel\nif (!require(\"readxl\")) install.packages(\"readxl\")\nif (!require(\"writexl\")) install.packages(\"writexl\")\n\n# Utilidades de RStudio/ Establecer directorio de trabajo\nif (!require(\"rstudioapi\")) install.packages(\"rstudioapi\")",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Paquetes en R</span>"
    ]
  },
  {
    "objectID": "07_paquetes.html#ejemplo-práctico-uso-de-paquetes-en-un-flujo-de-trabajo",
    "href": "07_paquetes.html#ejemplo-práctico-uso-de-paquetes-en-un-flujo-de-trabajo",
    "title": "8  Paquetes en R",
    "section": "8.4 Ejemplo práctico: Uso de paquetes en un flujo de trabajo",
    "text": "8.4 Ejemplo práctico: Uso de paquetes en un flujo de trabajo\nA continuación, se presenta un ejemplo práctico que integra diversos paquetes de R para realizar un análisis estadístico de datos. El script correspondiente a este ejemplo está disponible en el siguiente repositorio: https://github.com/Ludwing-MJ/Paquetes_Ej. Este ejercicio se basa en el ejemplo 2.2.8 del libro Diseños y análisis de experimentos de López y González (2016).\nContexto: Un silvicultor quiso comparar los efectos de cinco tratamientos de preparación del terreno sobre el crecimiento inicial en altura de plántulas de pino maximinoii. Dispuso de 25 parcelas y aplicó cada tratamiento a cinco parcelas seleccionadas al azar. La plantación fue realizada manualmente y, al final de cinco años, se midió la altura de todos los pinos y se calculó la altura promedio de cada parcela. Las medidas de las parcelas (en pies) fueron las siguientes.\n\n8.4.1 Preparación del área de trabajo\nAntes de iniciar un nuevo análisis, es fundamental crear un proyecto en R para garantizar una adecuada organización y reproducibilidad del trabajo. Se recomienda seguir las pautas de guardado y organización de archivos descritas en la sección 3.2. Una vez creado y guardado el proyecto, así como el script donde se desarrollará el análisis, se procede a instalar y cargar los paquetes necesarios. A continuación, se presenta un ejemplo práctico del código correspondiente:\n\n# Ejemplo práctico: Uso de paquetes\n# NOTA: Antes de trabajar, es necesario crear y guardar un nuevo script.\n\n# Instalación y carga de paquetes esenciales\n\n# Paquete que incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Paquete para diseños experimentales agrícolas\nif (!require(\"agricolae\")) install.packages(\"agricolae\")\n\n# Paquete para la importación de archivos Excel\nif (!require(\"readxl\")) install.packages(\"readxl\")\n\n# Paquete para la exportación de datos a Excel\nif (!require(\"writexl\")) install.packages(\"writexl\")\n\n# Paquete para establecer el directorio de trabajo automáticamente\nif (!require(\"rstudioapi\")) install.packages(\"rstudioapi\")\n\n\n\n8.4.2 Importación de los datos\nPara importar un archivo Excel con los datos de altura de las parcelas de pino, se utiliza el paquete readxl. Antes de realizar la importación, se establece el directorio de trabajo de manera automática utilizando el paquete rstudioapi. Esto asegura que los archivos se encuentren en la ubicación correcta para su procesamiento.\n\n# Establecer directorio de trabajo\nsetwd(dirname(rstudioapi::getActiveDocumentContext()$path))\n\n\n# Importar datos desde un archivo Excel\naltura_pino &lt;- read_excel(\"datos_arboles.xlsx\")\n\n\n\n8.4.3 Análisis de la varianza\nEl análisis de varianza (ANOVA) se realiza con el paquete agricolae para evaluar el efecto de diferentes tratamientos sobre la altura promedio de las parcelas. Además, se aplica la prueba de Tukey para realizar comparaciones múltiples entre los tratamientos.\n\n# Análisis de varianza\nmodelo_anova &lt;- aov(altura_ft ~ tratamiento, data = altura_pino)\nsummary(modelo_anova)\n\n            Df Sum Sq Mean Sq F value  Pr(&gt;F)   \ntratamiento  4  34.64    8.66   5.851 0.00276 **\nResiduals   20  29.60    1.48                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n# Prueba de Tukey\ncomparacion_tukey &lt;- HSD.test(modelo_anova, \"tratamiento\")\nprint(comparacion_tukey$groups)\n\n  altura_ft groups\nB      14.4      a\nA      13.4     ab\nE      11.8      b\nC      11.6      b\nD      11.4      b\n\n\n\n\n8.4.4 Visualización de resultados\nPara visualizar los resultados, se utiliza el paquete ggplot2, que permite crear un gráfico de cajas (boxplot) que muestra la distribución de la altura promedio por tratamiento. Este gráfico incluye un diseño minimalista y elimina la leyenda redundante.\n\n# Visualización de resultados\nggplot(altura_pino, aes(x = tratamiento, \n                        y = altura_ft, \n                        fill = tratamiento)) +\n  geom_boxplot() +\n  labs(title = \"Altura por Tratamiento\",\n       x = \"Tratamiento\",\n       y = \"Altura en pies\")+\n  theme_minimal()+ # Establece el tema del gráfico \n  theme(legend.position = \"none\")  # Remueve la leyenda redundante\n\n\n\n\n\n\n\n\n\n\n8.4.5 Exportación de resultados\nFinalmente, los resultados de la prueba de Tukey se exportan a un archivo Excel utilizando el paquete writexl. Además, el gráfico generado se guarda en formato PNG con la función ggsave.\n\n\n# Exportar resultados a Excel\nwrite_xlsx(comparacion_tukey$groups, \n           \"resultados_tukey.xlsx\", \n           col_names = TRUE, \n           format_headers = TRUE, \n           use_zip64 = FALSE)\n\n# Exportar gráficos\nggsave(\"ggplot_pino.png\")",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Paquetes en R</span>"
    ]
  },
  {
    "objectID": "01_cbasicos.html",
    "href": "01_cbasicos.html",
    "title": "1  Conceptos básicos de R",
    "section": "",
    "text": "1.1 ¿Qué es R?\nR es un lenguaje de programación y un entorno computacional ampliamente utilizado en el análisis estadístico, la visualización de datos y la investigación científica. Fue desarrollado por Ross Ihaka y Robert Gentleman en 1996 con el propósito de ofrecer una herramienta poderosa y flexible para realizar análisis reproducibles y visualizaciones de alta calidad (Ihaka & Gentleman, 1996). Desde su creación, R se ha consolidado como una de las herramientas más populares en las comunidades científica, académica y profesional.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Conceptos básicos de R</span>"
    ]
  },
  {
    "objectID": "01_cbasicos.html#qué-es-r",
    "href": "01_cbasicos.html#qué-es-r",
    "title": "1  Conceptos básicos de R",
    "section": "",
    "text": "1.1.1 Características principales de R\nEspecialización en análisis estadístico: R está diseñado para realizar análisis estadísticos complejos, desde pruebas básicas como t-tests y ANOVA hasta modelos avanzados como regresión y análisis multivariado.\nVisualización de datos: Incluye herramientas para crear gráficos de alta calidad y personalizables. Con paquetes como ggplot2, es posible generar visualizaciones avanzadas que permiten explorar y comunicar patrones en los datos de manera efectiva.\nLenguaje de código abierto: R es un software de código abierto, lo que lo hace gratuito y accesible para todos. Esto fomenta la colaboración y el desarrollo continuo por parte de una comunidad global de usuarios y desarrolladores.\nExtensibilidad mediante paquetes: R cuenta con una amplia colección de paquetes (más de 19,000 disponibles en CRAN hasta 2023) que amplían sus capacidades. Estos paquetes permiten realizar tareas específicas, como análisis genómico, minería de texto, modelado espacial y más (R Core Team, 2023).\nReproducibilidad: R promueve la investigación reproducible al permitir que los análisis se documenten en scripts, asegurando que los resultados puedan ser replicados por otros investigadores o por el mismo usuario en el futuro.\nInteroperabilidad: R puede integrarse con otros lenguajes de programación como Python, C++ y SQL, y es compatible con múltiples formatos de datos, como CSV, Excel, JSON y bases de datos relacionales.\n\n\n1.1.2 ¿Por qué es especial R?\nR no solo es una herramienta para realizar cálculos estadísticos, sino que también es un entorno completo para la manipulación de datos, la creación de gráficos y la automatización de flujos de trabajo. Su flexibilidad y capacidad de personalización lo convierten en una opción ideal para investigadores, analistas de datos y profesionales de diversas disciplinas. Además, su comunidad activa desarrolla constantemente nuevos paquetes y recursos, manteniéndolo en constante evolución.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Conceptos básicos de R</span>"
    ]
  },
  {
    "objectID": "01_cbasicos.html#qué-es-rstudio",
    "href": "01_cbasicos.html#qué-es-rstudio",
    "title": "1  Conceptos básicos de R",
    "section": "1.2 ¿Qué es RStudio?",
    "text": "1.2 ¿Qué es RStudio?\nRStudio es un Entorno de Desarrollo Integrado (IDE, por sus siglas en inglés) diseñado específicamente para trabajar con el lenguaje de programación R. Este entorno proporciona una interfaz amigable y herramientas avanzadas que optimizan el flujo de trabajo en R, facilitando tanto el análisis estadístico como la visualización de datos (Allaire et al., 2022).\n\n\n\n\n\n\n1.2.1 Características principales de RStudio\n\nInterfaz intuitiva y organizada: RStudio divide su interfaz en paneles que permiten acceder fácilmente a diferentes herramientas y funciones.\nSistema de proyectos: RStudio permite organizar el trabajo en proyectos, lo que facilita la gestión de archivos, scripts y datos relacionados con un análisis específico. Cada proyecto tiene su propio directorio de trabajo, lo que mejora la organización y la reproducibilidad.\nCompatibilidad con múltiples formatos: RStudio soporta la importación y exportación de datos en diversos formatos, como CSV, Excel, html y bases de datos SQL. Además, permite trabajar con gráficos interactivos y aplicaciones web mediante paquetes como shiny y plotly.\nIntegración con paquetes y extensiones: RStudio facilita la instalación y el uso de paquetes de R, como ggplot2 para gráficos, dplyr para manipulación de datos y tidyr para transformación de datos. También permite gestionar dependencias y actualizar paquetes de manera sencilla.\nSoporte multiplataforma: RStudio está disponible para sistemas operativos Windows, macOS y Linux, lo que lo hace accesible para una amplia variedad de usuarios.\nPersonalización y extensibilidad: Los usuarios pueden personalizar la apariencia y el comportamiento de RStudio, como cambiar temas, atajos de teclado y configuraciones de paneles. Además, se pueden integrar herramientas externas, como Git para control de versiones.\n\n\n\n1.2.2 Beneficios de usar RStudio\n\nEficiencia: Su diseño permite realizar tareas de análisis de datos de manera más rápida y organizada.\nReproducibilidad: Las herramientas integradas, como R Markdown y el sistema de proyectos, garantizan que los análisis puedan ser replicados fácilmente.\nAccesibilidad: Su interfaz gráfica es ideal tanto para principiantes como para usuarios avanzados.\nFlexibilidad: Permite trabajar con datos, gráficos, modelos estadísticos y aplicaciones interactivas en un solo entorno.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Conceptos básicos de R</span>"
    ]
  },
  {
    "objectID": "01_cbasicos.html#reproducibilidad-y-replicabilidad-en-la-investigación-científica",
    "href": "01_cbasicos.html#reproducibilidad-y-replicabilidad-en-la-investigación-científica",
    "title": "1  Conceptos básicos de R",
    "section": "1.3 Reproducibilidad y replicabilidad en la investigación científica",
    "text": "1.3 Reproducibilidad y replicabilidad en la investigación científica\nLa reproducibilidad y replicabilidad son pilares fundamentales de la investigación científica. Según Baker (2016), el 64% de los investigadores enfrenta dificultades para replicar estudios previos debido a una documentación insuficiente. Herramientas como Excel o Infostat suelen realizar cálculos en celdas ocultas y gráficos ajustados manualmente, lo que dificulta la replicación exacta de los análisis.\nR permite documentar cada paso del análisis mediante scripts, asegurando que los procedimientos puedan ser replicados y reinterpretados en el futuro. Esto no solo mejora la transparencia y la credibilidad científica, sino que también optimiza el tiempo y los recursos al facilitar la reutilización de métodos en nuevos estudios.\n\n\n\nUn script en R es comparable a una receta, ya que permite seguir cada paso de manera estructurada para reproducir un análisis específico. Al igual que una receta puede ajustarse al cambiar los ingredientes, un script puede adaptarse para llevar a cabo un análisis distinto utilizando nuevos conjuntos de datos.\n\n\n\n1.3.1 Reproducibilidad\nLa reproducibilidad se define como la capacidad de obtener los mismos resultados al emplear los mismos datos y métodos utilizados en un análisis original. Este concepto constituye un pilar fundamental en la investigación científica, ya que permite verificar y validar los hallazgos de un estudio. Según el informe de las National Academies of Sciences, Engineering, and Medicine (2019), la reproducibilidad asegura que los resultados puedan ser replicados por otros investigadores o incluso por el mismo autor en el futuro, siempre que se disponga de los datos y métodos originales.\nEntre las principales características de la reproducibilidad se encuentran:\n\nDisponibilidad de los datos originales: Es imprescindible que los datos empleados en el análisis estén accesibles para que otros puedan replicar el estudio.\nDocumentación detallada de los métodos: Los pasos, herramientas y configuraciones utilizadas deben estar claramente descritos para garantizar la repetición exacta del análisis.\nResultados consistentes: Al repetir el análisis con los mismos datos y procedimientos, los resultados obtenidos deben ser idénticos.\n\nLa reproducibilidad es esencial por varias razones:\n\nFomenta la transparencia: Permite que otros investigadores comprendan con precisión cómo se obtuvieron los resultados.\nFacilita la verificación: Ayuda a identificar posibles errores o inconsistencias en el análisis original.\nPromueve la colaboración científica: Proporciona una base sólida para que otros investigadores puedan construir sobre el trabajo existente, ampliando su alcance y aplicabilidad.\n\n\n\n1.3.2 Replicabilidad\nPor otro lado, la replicabilidad se refiere a la capacidad de obtener resultados consistentes al realizar un estudio similar en un contexto diferente, utilizando nuevos datos o métodos ligeramente modificados. Este concepto evalúa la generalización de los hallazgos y su aplicabilidad en diferentes escenarios. De acuerdo con las National Academies of Sciences, Engineering, and Medicine (2019), la replicabilidad es crucial para determinar la robustez y la aplicabilidad de los resultados científicos en nuevos contextos.\nLas características clave de la replicabilidad incluyen:\n\nUso de nuevos datos: Los datos empleados en el nuevo estudio deben ser diferentes a los del análisis original, pero representar un contexto similar.\nAdaptación de los métodos: Los procedimientos pueden ser ajustados o modificados para adaptarse a las características de los nuevos datos.\nCoherencia en los hallazgos: Aunque los resultados no sean idénticos, deben ser consistentes con los obtenidos en el estudio original.\n\nLa replicabilidad aporta beneficios significativos, tales como:\n\nEvaluación de la generalización: Permite determinar si los resultados del estudio original son aplicables en otros contextos o poblaciones.\nRefuerzo de la credibilidad científica: Incrementa la confianza en los hallazgos al demostrar que no son producto de circunstancias específicas.\nImpulso al avance del conocimiento: Facilita la exploración de nuevas aplicaciones o extensiones de los hallazgos originales, ampliando su impacto en la comunidad científica.\n\n\n\n1.3.3 Beneficios de la adopción de R para la Ciencia\nEl uso de R en la investigación científica ofrece múltiples ventajas que contribuyen a la reproducibilidad y replicabilidad de los estudios:\n\nTransparencia: El código generado en R es accesible para revisión por pares, lo que fomenta la transparencia en los análisis (The Turing Way Community, 2023).\nEficiencia: Los métodos desarrollados en R pueden ser reutilizados en nuevos estudios, optimizando recursos y tiempo (Gentleman & Temple Lang, 2007).\nCumplimiento de principios FAIR: El uso de R facilita la adherencia a los principios FAIR (Findable, Accessible, Interoperable, Reusable), promoviendo una gestión adecuada de los datos científicos (Wilkinson et al., 2016).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Conceptos básicos de R</span>"
    ]
  },
  {
    "objectID": "02_instalacion_confi.html",
    "href": "02_instalacion_confi.html",
    "title": "2  Instalación y configuración",
    "section": "",
    "text": "2.1 Descarga de R y RStudio\nAntes de comenzar a trabajar con R y RStudio, es fundamental realizar la instalación y configuración de ambos programas. R es un lenguaje de programación y entorno computacional ampliamente utilizado en el análisis estadístico, la visualización de datos y la investigación reproducible (Ihaka & Gentleman, 1996). Por su parte, RStudio es un Entorno de Desarrollo Integrado (IDE, por sus siglas en inglés) diseñado específicamente para trabajar con R, proporcionando una interfaz amigable y herramientas avanzadas que optimizan el flujo de trabajo (Allaire et al., 2022). Esta sección detalla los pasos necesarios para descargar, instalar y configurar ambos programas, asegurando un entorno de trabajo funcional y eficiente.\nPara utilizar R y RStudio, es necesario descargar ambos programas. Mientras que R proporciona el núcleo del lenguaje y las herramientas computacionales, RStudio actúa como una interfaz que simplifica su uso y mejora la experiencia del usuario.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación y configuración</span>"
    ]
  },
  {
    "objectID": "02_instalacion_confi.html#descarga-de-r-y-rstudio",
    "href": "02_instalacion_confi.html#descarga-de-r-y-rstudio",
    "title": "2  Instalación y configuración",
    "section": "",
    "text": "2.1.1 Descarga de R\nEs recomendable descargar una versión estable de R para evitar problemas de compatibilidad con paquetes que aún no han sido actualizados para las versiones más recientes. Por ejemplo, en este manual se utiliza la versión R 4.4.2, conocida por su estabilidad y amplio soporte (R Core Team, 2023).\nEl repositorio oficial de R se encuentra en el siguiente enlace: https://cran.r-project.org/bin/windows/base/old/. En esta página, se puede acceder a un directorio con todas las versiones de R disponibles. Para descargar una versión específica, basta con hacer clic en el nombre de la versión deseada. Esto abrirá un directorio con la documentación y los archivos correspondientes. El archivo que se debe descargar tiene una terminación -win.exe, y al hacer clic en él, se descargará automáticamente el instalador.\n\n\n2.1.2 Descarga de RStudio\nPara obtener RStudio, se debe visitar la página oficial de descargas de RStudio. En esta página, se puede descargar la versión más reciente de RStudio haciendo clic en el botón “Download RStudio Desktop for Windows”. Si el dispositivo utiliza un sistema operativo diferente a Windows, en la misma página se encuentran las versiones compatibles con otros sistemas operativos, como macOS y Linux (Allaire et al., 2022).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación y configuración</span>"
    ]
  },
  {
    "objectID": "02_instalacion_confi.html#instalación-de-r-y-rstudio",
    "href": "02_instalacion_confi.html#instalación-de-r-y-rstudio",
    "title": "2  Instalación y configuración",
    "section": "2.2 Instalación de R y RStudio",
    "text": "2.2 Instalación de R y RStudio\nLa instalación de R y RStudio debe realizarse en un orden específico para evitar conflictos y errores. A continuación, se describen los pasos detallados para cada programa:\n\n2.2.1 Instalación de R\n\nUna vez descargado el instalador de R, se debe ejecutar el archivo .exe.\nSeguir las instrucciones proporcionadas por el asistente de instalación.\nDurante el proceso, se pueden aceptar las configuraciones predeterminadas, a menos que se requiera una configuración personalizada.\n\n\n\n2.2.2 Instalación de RStudio\n\nDespués de instalar R, se debe ejecutar el instalador de RStudio descargado previamente.\nAl igual que con R, se pueden aceptar las configuraciones predeterminadas durante la instalación.\n\nEs importante mencionar que en un mismo dispositivo pueden coexistir varias versiones de R. RStudio permite seleccionar cuál de estas versiones se utilizará en cada proyecto desde su configuración, lo que resulta útil para trabajar con proyectos que requieren versiones específicas del lenguaje (R Core Team, 2023).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación y configuración</span>"
    ]
  },
  {
    "objectID": "02_instalacion_confi.html#configuración-inicial",
    "href": "02_instalacion_confi.html#configuración-inicial",
    "title": "2  Instalación y configuración",
    "section": "2.3 Configuración inicial",
    "text": "2.3 Configuración inicial\nUna vez instalados R y RStudio, es recomendable realizar una configuración inicial para optimizar el entorno de trabajo. Estas configuraciones permiten personalizar la experiencia del usuario, mejorar la organización y facilitar el desarrollo de análisis estadísticos. A continuación, se describen los pasos esenciales para configurar RStudio de manera eficiente.\n\n2.3.1 Seleccionar la versión de R\nRStudio permite elegir la versión de R que se utilizará, esto es especialmente útil si se tienen múltiples versiones instaladas en el mismo dispositivo. Esta funcionalidad garantiza la compatibilidad con proyectos que requieren versiones específicas del lenguaje (R Core Team, 2023). Para configurar la versión de R en RStudio, se deben seguir los siguientes pasos:\n\nIr a Tools &gt; Global Options &gt; General.\nEn el apartado R version, seleccionar la versión deseada de R.\n\n\n\n2.3.2 Configurar la apariencia de RStudio\nRStudio ofrece opciones de personalización para adaptar su apariencia a las preferencias del usuario, mejorando la experiencia de trabajo y reduciendo la fatiga visual durante sesiones prolongadas (Allaire et al., 2022). A continuación, se detallan las configuraciones principales:\n\n2.3.2.1 Cambiar el tema de la interfaz\n\nEn la barra de menú, se debe seleccionar Tools &gt; Global Options.\nEn la ventana emergente, se accede a la pestaña Appearance.\nEn esta sección, es posible elegir entre diferentes temas para la interfaz, como temas claros u oscuros. Por ejemplo, los temas oscuros como Cobalt son recomendables para reducir la fatiga visual.\nTambién se pueden ajustar el tamaño y el tipo de fuente para facilitar la lectura del código, según las preferencias del usuario.\n\n\n\n2.3.2.2 Configurar el panel de trabajo\nLa interfaz de RStudio está organizada en cuatro paneles principales: el editor de scripts, la consola, el entorno/archivos y los gráficos/ayuda. Estos paneles pueden reorganizarse según las necesidades del usuario para optimizar el flujo de trabajo. Los pasos para configurar los paneles son:\n\nDesde la barra de menú, se selecciona Tools &gt; Global Options &gt; Pane Layout.\nEn esta sección, se ajusta la disposición de los paneles. Por ejemplo, se puede colocar el editor de scripts en la parte superior izquierda y la consola en la parte inferior para facilitar el acceso.\nGuardar los cambios para aplicar la nueva disposición.\n\n\n\n2.3.2.3 Habilitar el número de líneas en el editor de scripts\nLa numeración de líneas en el editor de scripts facilita la navegación y depuración del código. Para habilitar esta opción:\n\nSe accede a Tools &gt; Global Options &gt; Code &gt; Display.\nEn esta sección, se marca la casilla Show line numbers para activar la numeración de líneas.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación y configuración</span>"
    ]
  },
  {
    "objectID": "02_instalacion_confi.html#organización-de-proyectos",
    "href": "02_instalacion_confi.html#organización-de-proyectos",
    "title": "2  Instalación y configuración",
    "section": "2.4 Organización de proyectos",
    "text": "2.4 Organización de proyectos\nLa organización de proyectos en RStudio es un aspecto clave para garantizar un flujo de trabajo eficiente, reproducible y bien estructurado. Una adecuada organización no solo facilita la gestión de archivos y scripts, sino que también mejora la colaboración y la reproducibilidad de los análisis. A continuación, se describen las mejores prácticas para organizar proyectos en RStudio.\n\n2.4.1 Crear un proyecto en RStudio\nRStudio permite crear proyectos para organizar de manera eficiente los archivos, datos y scripts relacionados con un análisis específico. Los pasos para crear un proyecto son los siguientes:\n\nEn la barra de menú, selecciona File &gt; New Project.\nElige entre las opciones disponibles:\n\nNew Directory: Crea un proyecto desde cero en una nueva carpeta.\nExisting Directory: Convierte una carpeta existente en un proyecto de RStudio.\nVersion Control: Clona un repositorio de Git para trabajar en un proyecto versionado.\n\nConfigurar el nombre y la ubicación del proyecto.\nHacer clic en Create Project para finalizar la configuración.\n\nEl uso de proyectos en RStudio permite mantener una estructura clara y organizada, lo que facilita la gestión de los recursos necesarios para el análisis (Allaire et al., 2022).\n\n\n2.4.2 Establecer un directorio de trabajo\nEl directorio de trabajo es la carpeta donde R buscará automáticamente los archivos y guardará los resultados generados durante el análisis. Para establecer el directorio de trabajo, se puede utilizar la función setwd() de la siguiente manera:\n\n# Establecer directorio de trabajo\nsetwd(\"ruta/del/directorio\")\n\nSin embargo, cuando se trabaja con proyectos en RStudio, el directorio de trabajo se configura automáticamente al abrir el archivo del proyecto, lo que elimina la necesidad de establecerlo manualmente. Esto mejora la reproducibilidad y evita errores relacionados con rutas incorrectas (R Core Team, 2023).\n\n\n2.4.3 Uso de archivos .Rproj\nEl archivo .Rproj es el núcleo del proyecto en RStudio. Este archivo contiene las configuraciones específicas del proyecto, como el directorio de trabajo, las opciones de visualización y otros ajustes personalizados. Al abrir un archivo .Rproj, se cargará automáticamente el entorno de trabajo asociado, lo que facilita la continuidad en el desarrollo del análisis.\n\n2.4.3.1 Beneficios de la organización de proyectos\nLa organización de proyectos en RStudio ofrece múltiples beneficios que impactan positivamente en la calidad y eficiencia del trabajo:\n\nReproducibilidad: Facilita que otros usuarios (o el propio usuario en el futuro) comprendan y reproduzcan el análisis, asegurando que los resultados sean consistentes.\nEficiencia: Reduce el tiempo perdido buscando archivos o configurando rutas manualmente, permitiendo un enfoque más directo en el análisis.\nColaboración: Mejora la comunicación y el trabajo en equipo al mantener una estructura clara y consistente, especialmente en proyectos compartidos.\nOptimización del flujo de trabajo: La combinación de una apariencia personalizada y una estructura organizada permite al usuario enfocarse en el análisis de datos de manera más eficiente y profesional (Allaire et al., 2022).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Instalación y configuración</span>"
    ]
  },
  {
    "objectID": "03_inicio.html",
    "href": "03_inicio.html",
    "title": "3  Primeros pasos en R",
    "section": "",
    "text": "3.1 Creación de scripts en RStudio\nComenzar a trabajar con R y RStudio puede parecer un desafío al principio, pero con una guía clara y organizada, el proceso se vuelve mucho más accesible. Esta sección está diseñada para acompañar al usuario en sus primeros pasos dentro de este entorno de programación, abordando desde la creación de scripts hasta las mejores prácticas para organizar archivos y proyectos. Estas bases son esenciales para garantizar un flujo de trabajo eficiente, reproducible y bien estructurado.\nUn script en RStudio no solo es un espacio para escribir código, sino también una herramienta clave para documentar y reproducir análisis de datos. Además, se introducirá el concepto de objetos en R, fundamentales para almacenar y manipular datos, junto con una descripción de los principales tipos de objetos (numéricos, texto, factores y lógicos). Este conocimiento inicial permitirá al usuario sentar las bases para realizar análisis estadísticos y visualizaciones de datos de manera efectiva.\nEl primer paso para trabajar en RStudio es crear un script, que es un archivo donde se escribe y guarda el código que se ejecutará en R. Existen dos métodos principales para crear un script en RStudio:\nUna vez creado, el script se convierte en el espacio de trabajo principal donde se desarrollarán los análisis y se documentarán los pasos realizados. Es importante guardar el script desde el inicio para evitar la pérdida de trabajo.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeros pasos en R</span>"
    ]
  },
  {
    "objectID": "03_inicio.html#creación-de-scripts-en-rstudio",
    "href": "03_inicio.html#creación-de-scripts-en-rstudio",
    "title": "3  Primeros pasos en R",
    "section": "",
    "text": "Manualmente: En la barra de menú, seleccionar File &gt; New File &gt; R Script.\nUtilizando atajos de teclado: Presionar la combinación de teclas Ctrl + Shift + N para crear un nuevo script de manera rápida.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeros pasos en R</span>"
    ]
  },
  {
    "objectID": "03_inicio.html#guardado-y-organización-de-archivos",
    "href": "03_inicio.html#guardado-y-organización-de-archivos",
    "title": "3  Primeros pasos en R",
    "section": "3.2 Guardado y organización de archivos",
    "text": "3.2 Guardado y organización de archivos\nGuardar y organizar los archivos de manera adecuada es fundamental para mantener un flujo de trabajo eficiente y reproducible. Para guardar un script, se debe seleccionar la opción “Save As…” en la pestaña “File”, lo que permitirá elegir la ubicación y el nombre del archivo. Se recomienda seguir estas prácticas:\n\nNombres descriptivos y consistentes: Utilizar nombres que describan claramente el contenido del archivo. Por ejemplo:\nPara scripts: analisis_rendimiento.R o 2023-10-15_analisis_maiz.R.\nPara datos: datos_suelo_2023.csv o resultados_finales.xlsx.\nEvitar espacios y caracteres especiales: Los nombres de los archivos no deben incluir espacios ni caracteres especiales, ya que esto puede generar errores en R. En su lugar, se recomienda usar guiones bajos (_) o guiones medios (-). Por ejemplo:\nEn lugar de analisis suelo.R, usar analisis_suelo.R.\nIncluir fechas en un formato estandarizado: Incorporar fechas en el formato YYYY-MM-DD ayuda a identificar rápidamente versiones o actualizaciones. Por ejemplo: 2023-10-15_importacion_datos.R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeros pasos en R</span>"
    ]
  },
  {
    "objectID": "03_inicio.html#organización-de-proyectos-y-directorios",
    "href": "03_inicio.html#organización-de-proyectos-y-directorios",
    "title": "3  Primeros pasos en R",
    "section": "3.3 Organización de proyectos y directorios",
    "text": "3.3 Organización de proyectos y directorios\nLa organización adecuada de los archivos en carpetas específicas para cada proyecto es esencial para garantizar un flujo de trabajo ordenado. Si se utiliza un archivo de proyecto .Rproj, este configurará automáticamente el directorio de trabajo, lo que facilita la gestión de los archivos relacionados. Se recomienda:\nCrear una carpeta específica para cada proyecto: Agrupar todos los elementos relacionados con un proyecto (scripts, datos, resultados) en una sola carpeta.\n\n3.3.1 Recomendaciones para la organización de archivos\nLa organización de archivos en RStudio es comparable a mantener una cocina bien ordenada: separar los utensilios, ingredientes y especias en lugares específicos facilita el trabajo y evita errores. Para lograrlo, se sugieren las siguientes prácticas:\n\nEstandarizar nombres de archivos: Usar nombres descriptivos, evitar caracteres especiales y seguir un formato uniforme.\nDocumentar los pasos del análisis: Incluir comentarios en los scripts para explicar cada paso del análisis.\nUtilizar proyectos de RStudio: Crear un archivo .Rproj para cada proyecto, lo que asegura que el entorno de trabajo esté configurado correctamente.\nRealizar copias de seguridad: Guardar versiones importantes de los archivos en un repositorio de control de versiones (como Git) o en una ubicación segura.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeros pasos en R</span>"
    ]
  },
  {
    "objectID": "03_inicio.html#introducción-a-los-objetos-en-r",
    "href": "03_inicio.html#introducción-a-los-objetos-en-r",
    "title": "3  Primeros pasos en R",
    "section": "3.4 Introducción a los objetos en R",
    "text": "3.4 Introducción a los objetos en R\nEn R, todo se maneja como un objeto, lo que significa que cualquier dato o estructura que se utilice en este lenguaje se representa como un objeto. Un objeto es una entidad que almacena información y tiene atributos como nombre, tipo y, en algunos casos, dimensiones. Los objetos son fundamentales para trabajar en R, ya que permiten almacenar, manipular y analizar datos de manera eficiente (R Core Team, 2023).\n\n3.4.1 Creación de objetos en R\nPara crear un objeto en R, se utiliza un operador de asignación, que puede ser = o &lt;-. Sin embargo, el uso de &lt;- es el estándar recomendado en la comunidad de R, ya que mejora la legibilidad del código y sigue las convenciones establecidas (Ihaka & Gentleman, 1996). Por ejemplo, para asignar el valor 10 a un objeto llamado x, se puede escribir:\n\n# Creación del primer objeto en R\nx &lt;- 10\n\nEl operador &lt;- indica que el valor a la derecha se asigna al nombre del objeto a la izquierda. Este enfoque es especialmente útil para mantener un código claro y organizado.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeros pasos en R</span>"
    ]
  },
  {
    "objectID": "03_inicio.html#tipos-de-objetos-en-r",
    "href": "03_inicio.html#tipos-de-objetos-en-r",
    "title": "3  Primeros pasos en R",
    "section": "3.5 Tipos de objetos en R",
    "text": "3.5 Tipos de objetos en R\nEn R, los objetos pueden clasificarse en diferentes tipos según el tipo de datos que almacenan. Los principales tipos de objetos son: numéricos, texto, factores y lógicos. A continuación, se describen en detalle cada uno de ellos.\n\n3.5.1 Objetos Numéricos\nLos objetos numéricos almacenan datos como números enteros o decimales. Son esenciales para representar variables cuantitativas, como edad, altura o peso. En R, los números se manejan como valores de punto flotante por defecto, lo que significa que incluso los enteros se tratan como números decimales.\nEjemplo de creación de objetos numéricos:\n\n# Creación de objetos numéricos\nedad &lt;- 21 \naltura_m &lt;- 1.70 \npeso_lb &lt;- 150\n\nNota importante: En R, el símbolo numeral (#) se utiliza para incluir comentarios dentro del código. Las líneas que comienzan con este símbolo no son ejecutadas por el programa. Los comentarios son útiles para documentar el código, explicar pasos específicos y facilitar su comprensión tanto para otros usuarios como para el propio autor en el futuro.\n\n\n3.5.2 Objetos de Texto\nLos objetos de texto, también conocidos como objetos de tipo carácter, almacenan cadenas de texto. Estos se escriben entre comillas dobles (\") o simples ('). Son útiles para representar información cualitativa, como nombres, descripciones o etiquetas.\nEjemplo de creación de objetos de texto:\n\n# Creación de objetos tipo carácter\nnombre &lt;- \"Juan\" \ncolor_favorito &lt;- \"azul\"\n\nLos objetos de texto son fundamentales para trabajar con datos categóricos o descriptivos, como nombres de variables, etiquetas de gráficos o valores de texto en bases de datos.\n\n\n3.5.3 Objetos de Tipo Factor\nLos objetos de tipo factor se utilizan para almacenar variables categóricas con niveles definidos. Estos niveles representan categorías discretas, como escalas, estados o clasificaciones. Los factores son especialmente útiles en análisis estadísticos, ya que permiten manejar variables categóricas de manera eficiente.\nEjemplo de creación de objetos tipo factor:\n\n# Creación de objetos tipo factor\nestado_civil &lt;- factor(\"soltero\") \nsexo &lt;- factor(\"masculino\")\n\nEn este ejemplo, estado_civil y sexo son factores con un único nivel. Los factores también pueden tener múltiples niveles, que se definen explícitamente al crearlos. Por ejemplo:\n\n# Creación de un factor con múltiples niveles\nestado_civil &lt;- factor(\"soltero\", levels = c(\"soltero\", \"casado\", \"divorciado\"))\nsexo &lt;- factor(\"masculino\", levels = c(\"masculino\", \"femenino\"))\n\n\n\n3.5.4 Objetos Lógicos\nLos objetos lógicos almacenan valores de tipo TRUE o FALSE, que resultan de comparaciones lógicas. Estos objetos son esenciales para realizar análisis condicionales, aplicar filtros y evaluar expresiones booleanas.\nEjemplo de creación de objetos lógicos:\n\n# Creación de objetos lógicos\nmayoria_de_edad &lt;- edad &gt;= 18\nmayoria_de_edad\n\n[1] TRUE\n\n\nEn este caso, la comparación edad &gt;= 18 evalúa si el valor de edad es mayor o igual a 18. El resultado (TRUE o FALSE) se almacena en el objeto mayoria_de_edad.\nLos objetos lógicos son ampliamente utilizados en tareas como la selección de datos, la creación de condiciones en bucles y la evaluación de reglas en análisis estadísticos.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeros pasos en R</span>"
    ]
  },
  {
    "objectID": "03_inicio.html#conclusión",
    "href": "03_inicio.html#conclusión",
    "title": "3  Primeros pasos en R",
    "section": "3.6 Conclusión",
    "text": "3.6 Conclusión\nLos objetos son la base del trabajo en R, ya que permiten almacenar y manipular datos de manera estructurada y eficiente. Comprender los diferentes tipos de objetos y cómo crearlos es un paso esencial para aprovechar al máximo las capacidades de este lenguaje. Desde datos numéricos hasta factores y valores lógicos, cada tipo de objeto tiene aplicaciones específicas que facilitan el análisis estadístico y la visualización de datos (R Core Team, 2023; Ihaka & Gentleman, 1996).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Primeros pasos en R</span>"
    ]
  },
  {
    "objectID": "04_datos.html",
    "href": "04_datos.html",
    "title": "4  Estructura de datos en R",
    "section": "",
    "text": "4.1 Vectores\nEn R, las estructuras de datos son esenciales para organizar, almacenar y manipular información de manera eficiente. Estas estructuras permiten trabajar con diferentes tipos de datos, desde valores individuales hasta colecciones complejas, facilitando el análisis estadístico y la visualización de datos. Entre las principales estructuras de datos en R se encuentran los vectores, data frames y listas, cada una con características específicas que las hacen adecuadas para distintas tareas (R Core Team, 2023).\nUn vector es la estructura de datos más básica y fundamental en R. Es una colección ordenada de elementos del mismo tipo, como números, texto o valores lógicos. Los vectores son unidimensionales, lo que significa que los datos se almacenan en una sola fila o columna. Por ejemplo, un vector puede representar una lista de edades, nombres o resultados de un experimento (Ihaka & Gentleman, 1996).\nLos vectores son esenciales en R porque muchas otras estructuras de datos, como los data frames y las matrices, están construidas a partir de ellos. Una característica clave de los vectores es que todos sus elementos deben ser del mismo tipo de dato, lo que garantiza consistencia en las operaciones realizadas sobre ellos.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estructura de datos en R</span>"
    ]
  },
  {
    "objectID": "04_datos.html#vectores",
    "href": "04_datos.html#vectores",
    "title": "4  Estructura de datos en R",
    "section": "",
    "text": "4.1.1 Creación de vectores\nPara crear un vector en R, se utiliza la función c(), que permite combinar elementos separados por comas. A continuación, se presentan ejemplos de creación de vectores de diferentes tipos:\n\n# 1. Creación de un vector numérico\nedades &lt;- c(17, 20, 18, 25)\n\n# 2. Creación de un vector de texto\nnombres &lt;- c(\"Juan\", \"Ana\", \"Luis\", \"María\")\n\n# 3. Creación de un vector lógico\nmayores_de_edad &lt;- edades &gt;= 18\n\nEn estos ejemplos:\n\nEl vector edades almacena valores numéricos.\nEl vector nombres contiene cadenas de texto.\nEl vector mayores_de_edad almacena valores lógicos (TRUE o FALSE) que resultan de una comparación lógica.\n\n\n\n4.1.2 Manipulación de vectores\nLos vectores en R permiten realizar una amplia variedad de operaciones matemáticas, lógicas y de manipulación de datos. Estas operaciones son fundamentales para el análisis estadístico y la transformación de datos. A continuación, se describen algunas de las operaciones más comunes:\n\n4.1.2.1 Acceso a elementos específicos\nSe pueden acceder a elementos individuales de un vector utilizando índices entre corchetes ([]). Los índices en R comienzan en 1.\n\n# Acceder al primer elemento del vector\nedades[1]\n\n[1] 17\n\n\nEn este ejemplo, edades[1] devuelve el primer elemento del vector edades, que es 17.\n\n\n4.1.2.2 Filtrado de elementos\nEs posible filtrar elementos de un vector aplicando condiciones lógicas. Esto resulta útil para seleccionar subconjuntos de datos.\n\n# Filtrar edades mayores a 20\nedades[edades &gt; 20]\n\n[1] 25\n\n\nEn este caso, la condición edades &gt; 20 devuelve un vector con los valores que cumplen la condición, es decir, las edades mayores a 20.\n\n\n4.1.2.3 Combinación de vectores\nLos vectores pueden combinarse para crear nuevos vectores utilizando la función c().\n\n# Combinar dos vectores\nnuevo_vector &lt;- c(edades, c(22, 21))\nnuevo_vector\n\n[1] 17 20 18 25 22 21\n\n\nAquí, el vector nuevo_vector combina los elementos del vector edades con los valores 22 y 21, generando un nuevo vector.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estructura de datos en R</span>"
    ]
  },
  {
    "objectID": "04_datos.html#data-frames",
    "href": "04_datos.html#data-frames",
    "title": "4  Estructura de datos en R",
    "section": "4.2 Data frames",
    "text": "4.2 Data frames\nUn data frame es una estructura de datos tabular en R, similar a una hoja de cálculo o una tabla en una base de datos. Organiza los datos en filas y columnas, donde cada columna es un vector que puede contener un tipo de dato diferente (por ejemplo, números, texto o factores). Cada fila representa una observación, mientras que cada columna corresponde a una variable (R Core Team, 2023).\nLos data frames son ideales para trabajar con datos estructurados, como encuestas, experimentos o bases de datos, ya que permiten realizar análisis estadísticos y visualizaciones de manera eficiente. Además, son compatibles con una amplia variedad de funciones y paquetes en R, lo que los convierte en una de las estructuras más utilizadas en este lenguaje (Wickham & Grolemund, 2017).\n\n4.2.1 Creación de data frames\nPara crear un data frame, se utiliza la función data.frame(), combinando vectores de igual longitud separados por comas. A continuación, se presenta un ejemplo usando los vectores creados en la sección anterior:\n\n# Creación de un data frame con vectores\ndatos &lt;- data.frame(nombres,  edades,  mayores_de_edad)\n\n# Visualización del data frame\ndatos\n\n  nombres edades mayores_de_edad\n1    Juan     17           FALSE\n2     Ana     20            TRUE\n3    Luis     18            TRUE\n4   María     25            TRUE\n\n\nEn este ejemplo:\n\nLa columna nombres contiene texto.\nLa columna edades almacena valores numéricos.\nLa columna mayores_de_edad contiene valores lógicos (TRUE o FALSE).\n\n\n\n4.2.2 Ventajas de un data frame\nLos data frames ofrecen múltiples ventajas que los hacen indispensables para el análisis de datos en R:\n\nEstructura clara: Cada fila representa una observación y cada columna una variable, lo que facilita la interpretación de los datos.\nCompatibilidad: Son compatibles con funciones estadísticas y de visualización, así como con paquetes populares como ggplot2 y dplyr.\nFlexibilidad: Permiten almacenar diferentes tipos de datos en columnas, como números, texto y factores.\n\n\n\n4.2.3 Manipulación de data frames\nLos data frames pueden manipularse fácilmente utilizando funciones básicas de R o herramientas avanzadas de paquetes como dplyr. A continuación, se describen algunas operaciones comunes:\n\n4.2.3.1 Acceso a columnas\nSe puede acceder a una columna específica utilizando el operador $:\n\n# Acceso a la columna 'nombres'\ndatos$nombres\n\n[1] \"Juan\"  \"Ana\"   \"Luis\"  \"María\"\n\n\n\n\n4.2.3.2 Filtrado de filas\nEs posible filtrar filas aplicando condiciones lógicas. Por ejemplo, para seleccionar las filas donde la edad sea mayor a 20:\n\n# Filtrar filas donde la edad sea mayor a 20\ndatos_filtrados &lt;- datos[datos$edades &gt; 20, ]\ndatos_filtrados\n\n  nombres edades mayores_de_edad\n4   María     25            TRUE",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estructura de datos en R</span>"
    ]
  },
  {
    "objectID": "04_datos.html#listas",
    "href": "04_datos.html#listas",
    "title": "4  Estructura de datos en R",
    "section": "4.3 Listas",
    "text": "4.3 Listas\nLas listas son estructuras de datos más flexibles que los data frames, ya que pueden contener elementos de diferentes tipos y longitudes, como vectores, data frames, matrices o incluso funciones. A diferencia de los data frames, las listas no requieren que los elementos tengan la misma longitud o tipo de dato, lo que las hace ideales para almacenar resultados complejos o datos heterogéneos (R Core Team, 2023).\n\n4.3.1 Creación de listas\nPara crear una lista, se utiliza la función list(). A continuación, se presenta un ejemplo:\n\n# Creación de una lista\nmi_lista &lt;- list(\n  nombres = c(\"Juan\", \"Ana\"),\n  edades = c(18, 20),\n  datos_completos = datos\n)\n\nEn este ejemplo:\n\nEl elemento nombres es un vector de texto.\nEl elemento edades es un vector numérico.\nEl elemento datos_completos es un data frame.\n\n\n\n4.3.2 Acceso a elementos de una lista\nLos elementos de una lista pueden accederse mediante su nombre o índice:\nPor nombre: Utilizando el operador $ o corchetes dobles [[ ]]\n\n# Acceso al elemento 'nombres' por nombre\nmi_lista$nombres\n\n[1] \"Juan\" \"Ana\" \n\n\nPor índice: Utilizando corchetes dobles [[ ]]:\n\n# Acceso al primer elemento de la lista\nmi_lista[[1]]\n\n[1] \"Juan\" \"Ana\"",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estructura de datos en R</span>"
    ]
  },
  {
    "objectID": "04_datos.html#comparación-y-conclusiones-data-frames-y-listas",
    "href": "04_datos.html#comparación-y-conclusiones-data-frames-y-listas",
    "title": "4  Estructura de datos en R",
    "section": "4.4 Comparación y conclusiones: Data Frames y Listas",
    "text": "4.4 Comparación y conclusiones: Data Frames y Listas\nLos data frames y las listas son estructuras de datos fundamentales en R, cada una con características específicas que las hacen adecuadas para diferentes tareas. Mientras que los data frames son ideales para trabajar con datos tabulares estructurados, las listas ofrecen una mayor flexibilidad para almacenar y manipular datos heterogéneos. A continuación, se presenta una comparación detallada entre ambas estructuras:\n\n\n\n\n\n\n\n\nCaracterística\nData Frame\nLista\n\n\n\n\nEstructura\nTabular (filas y columnas)\nColección de objetos heterogéneos\n\n\nTipos de datos\nColumnas con tipos diferentes\nElementos de cualquier tipo\n\n\nUso principal\nAnálisis estadístico y visualización\nAlmacenamiento de resultados complejos\n\n\nAcceso a elementos\nPor columnas o índices\nPor nombres o índices\n\n\n\nAmbas estructuras son esenciales en R, y su elección depende del tipo de datos y del análisis que se desee realizar. En el contexto del análisis estadístico, los data frames se utilizan habitualmente para almacenar datos tabulares, como encuestas o resultados experimentales, mientras que las listas son más adecuadas para almacenar resultados complejos, como salidas de modelos estadísticos, pruebas o análisis que combinan diferentes tipos de datos.\nPor ejemplo:\n\nUn data frame puede contener las respuestas de una encuesta, con columnas que representan variables como edad, género y puntuaciones.\nUna lista puede almacenar los resultados de un análisis estadístico, como coeficientes de regresión, valores p y gráficos generados.\n\nComprender las diferencias y aplicaciones de estas estructuras permite aprovechar al máximo las capacidades de R en el análisis de datos. La elección adecuada entre un data frame y una lista no solo facilita el manejo de los datos, sino que también optimiza el flujo de trabajo y la reproducibilidad del análisis (R Core Team, 2023; Wickham & Grolemund, 2017).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Estructura de datos en R</span>"
    ]
  },
  {
    "objectID": "05_importacion.html",
    "href": "05_importacion.html",
    "title": "5  Importación de datos",
    "section": "",
    "text": "5.1 Configuración inicial\nLa importación de datos es uno de los primeros pasos esenciales en cualquier análisis estadístico. R ofrece diversas herramientas y funciones para importar datos desde diferentes fuentes, como archivos CSV, Excel o páginas web en formato HTML. La capacidad de importar datos de manera eficiente y reproducible permite trabajar con grandes volúmenes de información de forma sistemática (R Core Team, 2023).\nAntes de importar datos, es importante asegurarse de que el directorio de trabajo esté correctamente configurado. Cuando se trabaja con proyectos de RStudio (.Rproj), el directorio se configura automáticamente. Sin embargo, para scripts independientes, se puede establecer el directorio usando la función setwd():\n# Establecer directorio de trabajo\nsetwd(\"ruta/del/directorio\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Importación de datos</span>"
    ]
  },
  {
    "objectID": "05_importacion.html#directorio-de-trabajo-o-working-directory",
    "href": "05_importacion.html#directorio-de-trabajo-o-working-directory",
    "title": "5  Importación de datos",
    "section": "5.2 Directorio de trabajo o Working Directory",
    "text": "5.2 Directorio de trabajo o Working Directory\nEl directorio de trabajo en R es el “punto de partida” desde donde el software buscará automáticamente los archivos necesarios (como datos y scripts) y guardará los resultados generados. Establecer correctamente el directorio de trabajo es esencial para garantizar la organización, la reproducibilidad y la eficiencia del análisis, especialmente cuando se trabaja con scripts independientes que no forman parte de un proyecto en RStudio. Si no se configura adecuadamente, se corre el riesgo de enfrentar errores como “archivo no encontrado” o de que el código deje de funcionar al mover el proyecto a otra ubicación o computadora (R Core Team, 2023).\n\n5.2.1 Razones para establecer un directorio de trabajo\nConfigurar un directorio de trabajo adecuado ofrece múltiples beneficios:\n\nReproducibilidad: Permite que el código funcione en cualquier computadora sin depender de rutas absolutas como C:/Usuario/MiPC/.... Esto asegura que el análisis sea portable y replicable.\nOrganización: Reduce errores como “archivo no encontrado” al mantener todos los elementos (datos, scripts, resultados) en una estructura clara y accesible.\nEficiencia: Facilita el acceso a los archivos, ya que no es necesario escribir rutas completas, solo los nombres de los archivos.\n\n\n\n5.2.2 Configuración automática del directorio de trabajo\nCuando se trabaja con scripts independientes, se puede establecer automáticamente el directorio de trabajo como la carpeta donde está guardado el script. Esto se logra utilizando el paquete rstudioapi:\n\n# Instalar y cargar el paquete rstudioapi\nif (!require(\"rstudioapi\")) install.packages(\"rstudioapi\")\n\n# Establecer el directorio de trabajo\nsetwd(dirname(rstudioapi::getActiveDocumentContext()$path))\n\n\n5.2.2.1 Explicación del código\n\nif (!require(\"rstudioapi\")) install.packages(\"rstudioapi\"): Esta estructura condicional verifica si el paquete rstudioapi está instalado. Si no lo está, lo instala automáticamente desde CRAN.\nrstudioapi::getActiveDocumentContext()$path: Obtiene la ruta completa del script actual. Por ejemplo, si el script está ubicado en C:/proyecto/scripts/analisis.R, esta función devuelve esa ruta completa.\ndirname(): Extrae la carpeta que contiene el script. Siguiendo el ejemplo anterior, convierte C:/proyecto/scripts/analisis.R en C:/proyecto/scripts/.\nsetwd(): Establece la carpeta extraída como el directorio de trabajo. Esto asegura que cualquier archivo en esa carpeta pueda ser accedido directamente sin necesidad de especificar rutas completas.\n\n\n\n\n5.2.3 Beneficios de establecer un directorio de trabajo\n\nPortabilidad: Si se mueve toda la carpeta del proyecto a otra ubicación, el código seguirá funcionando sin necesidad de ajustes adicionales.\nAutomatización: No es necesario modificar manualmente las rutas al compartir el script con otros usuarios, lo que facilita la colaboración.\nReproducibilidad: Garantiza que el análisis pueda ser replicado en diferentes entornos sin problemas de rutas.\n\n\n\n5.2.4 Consecuencias de no establecer un directorio de trabajo\n\nErrores frecuentes: R buscará archivos en una ubicación predeterminada (como la carpeta “Documentos”), lo que puede generar errores si los datos no están allí.\nCódigo no reproducible: Si otra persona ejecuta el script, será necesario modificar manualmente todas las rutas para que funcione.\n\n\n\n5.2.5 Recomendaciones prácticas\n\nGuardar el script antes de configurar el directorio: Es importante guardar el script antes de ejecutar la línea de configuración automática, ya que R necesita conocer su ubicación para establecer el directorio de trabajo correctamente.\nVerificar el directorio actual: Antes de importar datos o guardar resultados, se puede verificar el directorio de trabajo actual utilizando la función getwd():\n\n\n# Verificar el directorio de trabajo actual\ngetwd()\n\n\nUsar proyectos en RStudio: Siempre que sea posible, se recomienda trabajar dentro de un proyecto de RStudio (.Rproj), ya que este configura automáticamente el directorio de trabajo y facilita la organización.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Importación de datos</span>"
    ]
  },
  {
    "objectID": "05_importacion.html#importación-de-archivos-csv",
    "href": "05_importacion.html#importación-de-archivos-csv",
    "title": "5  Importación de datos",
    "section": "5.3 Importación de archivos CSV",
    "text": "5.3 Importación de archivos CSV\nLos archivos CSV (Comma-Separated Values) son uno de los formatos más comunes para almacenar datos tabulares. Según Wickham (2016), estos archivos son preferidos por su simplicidad y portabilidad. Para importar un archivo CSV, se utiliza la función read.csv():\n\n# Importar un archivo CSV\ndatos &lt;- read.csv(\"ruta/del/archivo/datos.csv\", \n                  header = TRUE, \n                  sep = \",\")\n\nParámetros importantes:\n\nheader = : Indica si el archivo tiene una fila de encabezado (TRUE) o no (FALSE).\nsep = : Especifica el separador entre valores (,, ;, \\t, etc.).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Importación de datos</span>"
    ]
  },
  {
    "objectID": "05_importacion.html#importación-de-archivos-excel",
    "href": "05_importacion.html#importación-de-archivos-excel",
    "title": "5  Importación de datos",
    "section": "5.4 Importación de archivos Excel",
    "text": "5.4 Importación de archivos Excel\nPara importar archivos Excel (.xlsx), se utiliza el paquete readxl (Wickham & Bryan, 2023). Este paquete ofrece funciones especializadas para leer datos de hojas de cálculo de Excel sin necesidad de conversiones previas.\n\n5.4.1 Pasos para importar un archivo Excel\n\nInstalar y cargar el paquete readxl.\n\n\n# Instalar y cargar el paquete readxl\nif (!require(\"readxl\")) install.packages(\"readxl\")\n\n\nImportar el archivo Excel\n\n\n# Importar un archivo Excel\ndatos_excel &lt;- read_excel(\"ruta/del/archivo/datos.xlsx\",\n                          sheet = \"Hoja1\",  #Nombre de la hoja\n                          col_names = TRUE/FALSE) #Primera fila como encabezado\n\nParámetros importantes:\n\nsheet = : Especifica la hoja del archivo que se desea importar.\ncol_names = : Indica si el archivo tiene una fila de encabezado (TRUE) o no (FALSE).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Importación de datos</span>"
    ]
  },
  {
    "objectID": "05_importacion.html#ejemplo-práctico-base-de-datos-de-estudiantes-usac",
    "href": "05_importacion.html#ejemplo-práctico-base-de-datos-de-estudiantes-usac",
    "title": "5  Importación de datos",
    "section": "5.5 Ejemplo práctico: Base de datos de estudiantes USAC",
    "text": "5.5 Ejemplo práctico: Base de datos de estudiantes USAC\nPara ilustrar estos conceptos, utilizaremos una base de datos recopilada en 2002 en la Universidad de San Carlos de Guatemala, que contiene información de 460 estudiantes de diversas facultades. Esta base de datos está disponible en ambos formatos (CSV y Excel) y será utilizada a lo largo del manual.\n\n# Instalar y cargar el paquete readxl\nif (!require(\"readxl\")) install.packages(\"readxl\")\n\n# Importar datos en formato CSV\ndatos_csv &lt;- read.csv(\"datos_estudiantes.csv\", \n                     header = TRUE, \n                     sep = \",\")\n\n# Importar datos en formato Excel\ndatos_excel &lt;- read_excel(\"datos_estudiantes_2002.xlsx\",\n                         sheet = \"datos\",\n                         col_names = TRUE)\n\n# Visualizar los primeros registros\nhead(datos_csv)  # Muestra las primeras 6 filas\n\n\n5.5.1 Verificación de datos importados\nDespués de importar los datos, es importante verificar que la importación se realizó correctamente. R ofrece varias funciones para este propósito:\n\n# Estructura del data frame\nstr(datos_csv)\n\n# Resumen estadístico básico\nsummary(datos_csv)\n\n# Dimensiones del data frame\ndim(datos_csv)\n\n\n\n5.5.2 Notas importantes\n\nUbicación de archivos: Cuando se trabaja con proyectos de RStudio, los archivos deben estar en el directorio del proyecto para facilitar su acceso.\nCodificación de caracteres: En caso de problemas con caracteres especiales (ñ, tildes), se puede especificar la codificación:\n\ndatos &lt;- read.csv(\"archivo.csv\", encoding = \"UTF-8\")",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Importación de datos</span>"
    ]
  },
  {
    "objectID": "06_operadores.html",
    "href": "06_operadores.html",
    "title": "6  Operadores en R",
    "section": "",
    "text": "6.1 Tipos de operadores en R\nEn R, los operadores son herramientas fundamentales que permiten realizar cálculos, comparaciones, asignaciones y manipulaciones de datos. Son el equivalente a las herramientas básicas de un taller, que se combinan para construir soluciones más complejas. Comprender su funcionamiento es esencial para aprovechar al máximo las capacidades del lenguaje en el análisis estadístico y la programación (R Core Team, 2023).\nLos operadores en R se clasifican en diferentes categorías según su función. A continuación, se describen los principales tipos de operadores disponibles en el lenguaje, junto con ejemplos prácticos para ilustrar su uso.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Operadores en R</span>"
    ]
  },
  {
    "objectID": "06_operadores.html#tipos-de-operadores-en-r",
    "href": "06_operadores.html#tipos-de-operadores-en-r",
    "title": "6  Operadores en R",
    "section": "",
    "text": "Tipo de Operador\nEjemplo\nDescripción\n\n\n\n\nAritméticos\n+, -, *, /\nRealizan operaciones matemáticas básicas como suma, resta, multiplicación, etc.\n\n\nLógicos\n&gt;, &lt;, ==, !=\nComparan valores y devuelven un resultado lógico (TRUE o FALSE).\n\n\nAsignación\n&lt;-, =\nAsignan valores a objetos.\n\n\nManipulación de datos\n$, [], :\nAcceden o manipulan elementos dentro de estructuras de datos.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Operadores en R</span>"
    ]
  },
  {
    "objectID": "06_operadores.html#operadores-de-asignación",
    "href": "06_operadores.html#operadores-de-asignación",
    "title": "6  Operadores en R",
    "section": "6.2 Operadores de Asignación",
    "text": "6.2 Operadores de Asignación\nLos operadores de asignación se utilizan para crear objetos y almacenar valores en ellos. En R, los operadores más comunes son &lt;- y =. Aunque ambos cumplen la misma función, el uso de &lt;- es el estándar recomendado en la comunidad de R, ya que evita conflictos con otros operadores lógicos (Ihaka & Gentleman, 1996).\n\n6.2.1 Ejemplo práctico\n\n# Asignación de valores a objetos\nx &lt;- 10          # Asignar el valor 10 al objeto x\ny = 20           # Asignar el valor 20 al objeto y (menos recomendado)\n\n# Uso de objetos\nsuma &lt;- x + y    # Resultado: 30\n\nNota: Aunque = puede ser utilizado para asignar valores, su uso no es recomendado en contextos profesionales debido a posibles confusiones con el operador lógico de igualdad (==).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Operadores en R</span>"
    ]
  },
  {
    "objectID": "06_operadores.html#operadores-aritméticos",
    "href": "06_operadores.html#operadores-aritméticos",
    "title": "6  Operadores en R",
    "section": "6.3 Operadores aritméticos",
    "text": "6.3 Operadores aritméticos\nLos operadores aritméticos permiten realizar operaciones matemáticas básicas y avanzadas. Son fundamentales para trabajar con datos numéricos y realizar cálculos en análisis estadísticos. Estos operadores operan sobre valores numéricos y devuelven resultados numéricos.\nLos operadores aritméticos permiten realizar operaciones matemáticas básicas y avanzadas. Son fundamentales para trabajar con datos numéricos y realizar cálculos en análisis estadísticos. Estos operadores operan sobre valores numéricos y devuelven resultados numéricos.\n\n\n\nOperador\nAcción\nEjemplo\nResultado\n\n\n\n\n+\nSuma\n5 + 3\n8\n\n\n-\nResta\n10 - 4\n6\n\n\n*\nMultiplicación\n6 * 2\n12\n\n\n/\nDivisión\n15 / 3\n5\n\n\n^\nPotencia\n2 ^ 3\n8\n\n\n%/%\nDivisión entera\n17 %/% 5\n3\n\n\n%%\nMódulo o residuo\n17 %% 5\n2\n\n\n\n\n6.3.1 Ejemplo práctico\nEn este ejemplo, se observa cómo los operadores aritméticos pueden ser utilizados tanto para cálculos simples como para operaciones más específicas, como obtener el cociente y el residuo de una división. Estas operaciones son útiles en contextos como la creación de nuevas variables derivadas o el análisis de datos numéricos.\n\n# Ejemplo práctico del uso de operadores aritméticos\n# Operaciones básicas\nresultado_suma &lt;- 5 + 3        # Resultado: 8\nresultado_resta &lt;- 10 - 4      # Resultado: 6\nresultado_mult &lt;- 6 * 2        # Resultado: 12\nresultado_div &lt;- 15 / 3        # Resultado: 5\nresultado_pot &lt;- 2 ^ 3         # Resultado: 8\n\n# División entera y residuo\ncociente &lt;- 17 %/% 5           # Resultado: 3\nresiduo &lt;- 17 %% 5             # Resultado: 2",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Operadores en R</span>"
    ]
  },
  {
    "objectID": "06_operadores.html#operadores-lógicos",
    "href": "06_operadores.html#operadores-lógicos",
    "title": "6  Operadores en R",
    "section": "6.4 Operadores lógicos",
    "text": "6.4 Operadores lógicos\nLos operadores lógicos permiten realizar comparaciones y evaluaciones condicionales. Son esenciales para la toma de decisiones en el código, como filtrar datos o establecer reglas condicionales. Estos operadores trabajan con valores lógicos (TRUE o FALSE) y se utilizan para evaluar condiciones.\n\n\n\n\n\n\n\n\n\nOperador\nAcción\nEjemplo\nResultado\n\n\n\n\n&gt;\nMayor que\n5 &gt; 3\nTRUE\n\n\n&lt;\nMenor que\n5 &lt; 3\nFALSE\n\n\n&gt;=\nMayor o igual que\n5 &gt;= 5\nTRUE\n\n\n&lt;=\nMenor o igual que\n5 &lt;= 4\nFALSE\n\n\n==\nIgualdad\n5 == 5\nTRUE\n\n\n!=\nDesigualdad\n5 != 3\nTRUE\n\n\n&\nY lógico (AND)\n(5 &gt; 3) & (4 &gt; 2)\nTRUE\n\n\n`\nO lógico (OR)\n(4 &lt; 2)  ` (5 &gt; 3)\nTRUE\n\n\n!\nNegación lógica\n!(5 &gt; 3)\nFALSE\n\n\n\n\n6.4.1 Ejemplo práctico\nLos operadores lógicos son especialmente útiles en tareas como la selección de datos, la creación de condiciones en bucles y la evaluación de reglas en análisis estadísticos (R Core Team, 2023).\n\n# Ejemplo práctico del uso de operadores lógicos\n# Comparaciones simples\nedad &lt;- 25\nes_mayor &lt;- edad &gt; 18                # Resultado: TRUE\nes_menor &lt;- edad &lt; 30                # Resultado: TRUE\nes_igual &lt;- edad == 25               # Resultado: TRUE\nes_diferente &lt;- edad != 20           # Resultado: TRUE\n\n# Operaciones lógicas compuestas\npeso_Kg &lt;- 70\naltura &lt;- 1.75\nimc &lt;- peso_Kg / (altura^2)\n\nsobrepeso &lt;- imc &gt;= 25 & imc &lt; 30    # Evaluación de sobrepeso\npeso_normal &lt;- imc &gt;= 18.5 & imc &lt; 25 # Evaluación de peso normal\n\nEn este ejemplo, se observa cómo los operadores lógicos pueden ser utilizados para evaluar condiciones simples y compuestas. Por ejemplo, se calcula el índice de masa corporal (IMC) y se evalúa si el valor corresponde a un rango de peso normal o sobrepeso.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Operadores en R</span>"
    ]
  },
  {
    "objectID": "06_operadores.html#operadores-de-manipulación-de-datos",
    "href": "06_operadores.html#operadores-de-manipulación-de-datos",
    "title": "6  Operadores en R",
    "section": "6.5 Operadores de Manipulación de Datos",
    "text": "6.5 Operadores de Manipulación de Datos\nLos operadores de manipulación de datos permiten acceder, seleccionar y modificar elementos dentro de estructuras de datos como vectores, listas o data frames. Estos operadores son esenciales para trabajar con datos organizados y realizar análisis estadísticos.\n\n\n\n\n\n\n\n\n\nOperador\nAcción\nEjemplo\nResultado\n\n\n\n\n[]\nAcceso a elementos por posición\nvector[1]\nPrimer elemento del vector\n\n\n[ , ]\nAcceso a filas y columnas en un data frame\ndata[1, 2]\nElemento en la fila 1, columna 2\n\n\n$\nAcceso a una columna específica en un data frame\ndata$columna\nColumna seleccionada\n\n\n:\nCreación de secuencias\n1:10\nSecuencia del 1 al 10\n\n\n\n\n6.5.1 Ejemplo práctico\n\n# Crear un vector\nvector &lt;- c(10, 20, 30, 40, 50)\n\n# Acceder al primer elemento\nprimer_elemento &lt;- vector[1]       # Resultado: 10\n\n# Crear un data frame\ndata &lt;- data.frame(\n  nombre = c(\"Juan\", \"Ana\", \"Luis\"),\n  edad = c(25, 30, 22),\n  peso = c(70, 65, 80)\n)\n\n# Acceder a una columna\ncolumna_edad &lt;- data$edad      # Resultado: c(25, 30, 22)\n\n# Acceder a un elemento específico\nelemento &lt;- data[2, 3]       # Resultado: 65 (peso de Ana)\n\nEn este ejemplo, se observa cómo los operadores de manipulación de datos permiten acceder a elementos específicos dentro de estructuras de datos. Esto es especialmente útil para filtrar, transformar y analizar datos en R.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Operadores en R</span>"
    ]
  },
  {
    "objectID": "06.1_funciones.html",
    "href": "06.1_funciones.html",
    "title": "7  Funciones en R",
    "section": "",
    "text": "7.1 Definición y características de las funciones en R\nLas funciones son uno de los pilares fundamentales de la programación en R. Constituyen bloques de código que encapsulan una serie de instrucciones diseñadas para realizar tareas específicas. Estas permiten automatizar procesos, reducir la repetición de código y mejorar la legibilidad de los scripts. Comprender cómo funcionan las funciones y cómo crearlas es esencial para aprovechar al máximo las capacidades de R en el análisis estadístico y la programación (R Core Team, 2023; Wickham & Grolemund, 2017).\nEn esta sección, se explorará qué son las funciones, cómo se utilizan y cómo se pueden crear funciones personalizadas para resolver problemas específicos.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funciones en R</span>"
    ]
  },
  {
    "objectID": "06.1_funciones.html#definición-y-características-de-las-funciones-en-r",
    "href": "06.1_funciones.html#definición-y-características-de-las-funciones-en-r",
    "title": "7  Funciones en R",
    "section": "",
    "text": "7.1.1 ¿Qué es una función?\nUna función en R es un objeto que toma uno o más valores de entrada (llamados argumentos), realiza una serie de operaciones con ellos y devuelve un resultado. Las funciones son esenciales para estructurar el código de manera eficiente y reutilizable (Chambers, 2008).\nCada función en R tiene tres componentes principales:\n\nNombre: Es el identificador que se utiliza para llamar a la función.\nArgumentos: Son los valores de entrada que la función necesita para realizar sus operaciones.\nCuerpo: Es el conjunto de instrucciones que define lo que la función hace.\n\n\n\n7.1.2 Tipos de funciones\nEn R, las funciones se dividen en dos categorías principales:\n\nFunciones predefinidas (built-in): Estas funciones vienen incluidas en R o en paquetes adicionales y están diseñadas para realizar tareas comunes, como cálculos matemáticos, operaciones estadísticas, manipulación de datos y visualización.\nFunciones personalizadas (user-defined): Estas son creadas por el usuario para realizar tareas específicas que no están cubiertas por las funciones predefinidas. Son útiles para automatizar procesos repetitivos o realizar cálculos complejos.\n\n\n\n7.1.3 Funciones predefinidas en R\nLas funciones predefinidas son herramientas esenciales en R, ya que permiten realizar operaciones comunes de manera rápida y eficiente. A continuación, se presentan algunos ejemplos de funciones predefinidas ampliamente utilizadas:\nEjemplos de funciones predefinidas:\n\nmean(): Calcula la media aritmética de un conjunto de datos.\n\n\n# Ejemplo del uso de la función mean\ndatos &lt;- c(1, 2, 3, 4, 5)\nmedia &lt;- mean(datos)\nmedia  # Resultado: \n\n[1] 3\n\n\n\nsum(): Calcula la suma de los elementos de un vector.\n\n\n# Ejemplo del uso de la función sum\nsuma &lt;- sum(datos)\nsuma  # Resultado: \n\n[1] 15\n\n\n\nsd(): Calcula la desviación estándar.\n\n\n# Ejemplo del uso de la función sd\ndesviacion &lt;- sd(datos)\ndesviacion  # Resultado: \n\n[1] 1.581139\n\n\n\nsummary(): Proporciona un resumen estadístico de un conjunto de datos.\n\n\n# Ejemplo del uso de la función summary\nresumen &lt;- summary(datos)\nresumen  # Resultado:\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      1       2       3       3       4       5 \n\n\nEstas funciones son ampliamente utilizadas y no requieren que el usuario las defina, ya que están disponibles de forma predeterminada en R (R Core Team, 2023).\n\n7.1.3.1 Funciones personalizadas en R\nLas funciones personalizadas son aquellas que el usuario crea para realizar tareas específicas que no están cubiertas por las funciones predefinidas. Estas funciones son útiles cuando se necesita automatizar procesos repetitivos o realizar cálculos complejos que no están disponibles en las funciones estándar.\nEjemplo de una función personalizada:\nSe puede crear una función para calcular el área de un círculo dado su radio:\n\n# Función para calcular el area de un circulo\ncalcular_area_circulo &lt;- function(radio) {\n  area &lt;- pi * radio^2\n  return(area)\n}\n\n# Uso de la función\narea &lt;- calcular_area_circulo(5)\narea  # Resultado: \n\n[1] 78.53982\n\n\nEn este caso:\n\nEl usuario define la lógica de la función.\nEspecifica los argumentos necesarios (radio).\nUtiliza la función para realizar cálculos.\n\n\n\n\n7.1.4 Diferencias entre funciones predefinidas y personalizadas\n\n\n\n\n\n\n\n\nCaracterística\nFunciones predefinidas\nFunciones personalizadas\n\n\n\n\nDisponibilidad\nIncluidas en R o en paquetes\nCreadas por el usuario\n\n\nFlexibilidad\nLimitada a las tareas para las que fueron diseñadas\nTotalmente adaptables a las necesidades del usuario\n\n\nEjemplos\nmean(), sum(), sd(), summary()\ncalcular_area_circulo()\n\n\nReutilización\nReutilizables en cualquier script\nReutilizables si se definen en el entorno o se guardan en un archivo",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funciones en R</span>"
    ]
  },
  {
    "objectID": "06.1_funciones.html#usos-y-beneficios-de-las-funciones-en-r",
    "href": "06.1_funciones.html#usos-y-beneficios-de-las-funciones-en-r",
    "title": "7  Funciones en R",
    "section": "7.2 Usos y beneficios de las funciones en R",
    "text": "7.2 Usos y beneficios de las funciones en R\nLas funciones en R ofrecen múltiples beneficios que las convierten en herramientas indispensables para cualquier usuario. Entre los principales usos y ventajas se encuentran:\n\nReutilización de código: Una vez que se define una función, esta puede ser utilizada en diferentes partes de un proyecto o incluso en otros proyectos, evitando la repetición de código.\nModularidad: Las funciones permiten dividir problemas complejos en partes más pequeñas y manejables, lo que facilita la organización del código.\nLegibilidad: Al encapsular operaciones complejas dentro de funciones, el código se vuelve más fácil de leer y entender.\nAutomatización: Las funciones permiten automatizar tareas repetitivas, ahorrando tiempo y esfuerzo.\n\nEjemplo de automatización con funciones personalizadas:\nSupongamos que se necesita calcular el área de varios círculos con diferentes radios. En lugar de repetir el cálculo manualmente, se puede usar una función personalizada:\n\nradios &lt;- c(1, 2, 3, 4, 5)\n\n# Aplicar la función a cada radio\nareas &lt;- calcular_area_circulo(radios)\nareas  # Resultado:\n\n[1]  3.141593 12.566371 28.274334 50.265482 78.539816",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funciones en R</span>"
    ]
  },
  {
    "objectID": "06.1_funciones.html#cómo-crear-funciones-en-r-sintaxis-y-ejemplos-básicos",
    "href": "06.1_funciones.html#cómo-crear-funciones-en-r-sintaxis-y-ejemplos-básicos",
    "title": "7  Funciones en R",
    "section": "7.3 Cómo crear funciones en R: Sintaxis y ejemplos básicos",
    "text": "7.3 Cómo crear funciones en R: Sintaxis y ejemplos básicos\n\n7.3.1 Sintaxis básica\nLa creación de funciones en R sigue una estructura sencilla:\n\nnombre_funcion &lt;- function(argumento1, argumento2, ...) {\n  # Cuerpo de la función\n  # Operaciones\n  return(resultado)\n}\n\n\n\n7.3.2 Elementos clave de una función\n\nNombre de la función: Debe ser descriptivo y reflejar la tarea que realiza.\nArgumentos: Son los valores de entrada que la función necesita. Pueden tener valores por defecto.\nCuerpo de la función: Contiene las operaciones que se ejecutan cuando se llama a la función.\nValor de retorno: Especificado con return(), aunque no es obligatorio. Si no se usa, la función devuelve el último valor calculado.\n\n\n\n7.3.3 Ejemplo básico\nSe puede crear una función para convertir grados Celsius a Fahrenheit:\n\n# Fucnión para convertir de grados celsius a fahrenheit\ncelsius_a_fahrenheit &lt;- function(celsius) {\n  fahrenheit &lt;- (celsius * 9/5) + 32\n  return(fahrenheit)\n}\n\n# Uso de la función\ntemperatura &lt;- celsius_a_fahrenheit(25)\ntemperatura  # Resultado:\n\n[1] 77",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Funciones en R</span>"
    ]
  },
  {
    "objectID": "08_manipulacion.html",
    "href": "08_manipulacion.html",
    "title": "9  Manipulación de datos con dplyr y tidyr",
    "section": "",
    "text": "9.1 Introducción a los paquetes dplyr y tidyr\nLos paquetes dplyr y tidyr son componentes fundamentales del ecosistema tidyverse, diseñados para simplificar y optimizar la manipulación y transformación de datos en R. Estas herramientas permiten realizar tareas comunes de análisis de datos de manera eficiente, reproducible y con una sintaxis clara e intuitiva (Wickham et al., 2023). En esta sección, se explorarán las principales funciones de estos paquetes, junto con ejemplos prácticos que ilustran su uso.\nEl paquete dplyr está especializado en la manipulación de datos tabulares, ofreciendo funciones específicas para realizar operaciones como filtrar filas, seleccionar columnas, crear nuevas variables y resumir datos. Su diseño está optimizado para trabajar con estructuras como data frames y tibbles, proporcionando un rendimiento superior y una sintaxis más legible en comparación con las funciones base de R.\nPor otro lado, el paquete tidyr se centra en la reorganización de datos, facilitando la transformación entre formatos “ancho” y “largo”. Estas transformaciones son esenciales para preparar los datos de manera adecuada antes de su análisis o visualización, asegurando que estén en el formato más conveniente para las herramientas de análisis.\nPara ilustrar el uso de estas herramientas, en esta sección se desarrollará un ejemplo práctico que permitirá explorar las principales funciones de manipulación de datos. El script correspondiente a este ejemplo está disponible en el siguiente repositorio: Repositorio de ejemplo - Manipulación de datos.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "08_manipulacion.html#operaciones-básicas-con-dplyr",
    "href": "08_manipulacion.html#operaciones-básicas-con-dplyr",
    "title": "9  Manipulación de datos con dplyr y tidyr",
    "section": "9.2 Operaciones básicas con dplyr",
    "text": "9.2 Operaciones básicas con dplyr\n\n9.2.1 Filtrar filas con filter()\nLa función filter() se utiliza para seleccionar filas de un data frame que cumplen con una o más condiciones lógicas. Esta operación es útil para extraer subconjuntos de datos relevantes para un análisis específico.\nSintaxis básica:\n\nfilter(data, condición)\n\nEjemplo práctico: Filtrar estudiantes con un peso mayor a 65 kg.\n\n# Crear un data frame de ejemplo\ndatos &lt;- data.frame(\n  nombre = c(\"Juan\", \"Ana\", \"Luis\", \"María\"),\n  edad = c(18, 22, 20, 19),\n  peso = c(70, 55, 80, 60),\n  altura = c(1.75, 1.60, 1.80, 1.65)\n)\n\n# Filtrar estudiantes con peso mayor a 65 kg\nestudiantes_pesados &lt;- datos %&gt;% \n  filter(peso &gt; 65)\n\n# Visualizar el resultado\nestudiantes_pesados\n\n  nombre edad peso altura\n1   Juan   18   70   1.75\n2   Luis   20   80   1.80\n\n\nExplicación: El resultado es un data frame que incluye únicamente las filas donde la variable peso es mayor a 65. Esta operación permite enfocar el análisis en un subconjunto específico de datos, lo que resulta útil en estudios que requieren segmentación de información.\n\n\n9.2.2 Seleccionar columnas con select()\nLa función select() permite extraer columnas específicas de un data frame. Esto es útil para reducir la cantidad de datos visibles o para trabajar únicamente con las variables necesarias.\nSintaxis básica:\n\nselect(data, columnas)\n\nEjemplo práctico: Seleccionar las columnas nombre y edad.\n\n# Seleccionar columnas específicas\ndatos_reducidos &lt;- datos %&gt;%\n  select(nombre, edad)\n\n# Visualizar el resultado\ndatos_reducidos\n\n  nombre edad\n1   Juan   18\n2    Ana   22\n3   Luis   20\n4  María   19\n\n\nExplicación: El resultado es un data frame que contiene únicamente las columnas nombre y edad. Esto es especialmente útil cuando se desea exportar información específica o simplificar la visualización de los datos.\n\n\n9.2.3 Crear nuevas columnas con mutate()\nLa función mutate() permite añadir nuevas columnas calculadas a un data frame. Esta operación es esencial para realizar cálculos derivados de las variables existentes.\nSintaxis básica:\n\nmutate(data, nueva_columna = expresión)\n\nEjemplo práctico: Calcular el índice de masa corporal (IMC) de los estudiantes.\n\n# Calcular el IMC\ndatos &lt;- datos %&gt;%\n  mutate(IMC = peso / (altura^2))\n\n# Visualizar el resultado\ndatos\n\n  nombre edad peso altura      IMC\n1   Juan   18   70   1.75 22.85714\n2    Ana   22   55   1.60 21.48437\n3   Luis   20   80   1.80 24.69136\n4  María   19   60   1.65 22.03857\n\n\nExplicación: Se añade una nueva columna llamada IMC al data frame, calculada como el peso dividido por el cuadrado de la altura. Esta operación permite enriquecer los datos con información derivada, facilitando análisis más detallados.\n\n\n9.2.4 Agrupar y resumir datos con group_by() y summarize()\nLa combinación de group_by() y summarize() permite calcular estadísticas por grupo. Esto es útil para obtener resúmenes de datos categorizados, como promedios, sumas o conteos.\nSintaxis básica:\n\n  data %&gt;%\n  group_by(grupo) %&gt;%\n  summarize(resumen = función(variable))\n\nEjemplo práctico: Calcular el peso promedio por grupo de edad (mayores y menores de 20 años).\n\n# Calcular peso promedio por grupo de edad\npeso_promedio &lt;- datos %&gt;%\n  mutate(grupo_edad = ifelse(edad &gt;= 20, \n                             \"Mayor o igual a 20\", \n                             \"Menor a 20\")) %&gt;%\n  group_by(grupo_edad) %&gt;%\n  summarize(peso_promedio = mean(peso))\n\n# Visualizar el resultado\npeso_promedio\n\n# A tibble: 2 × 2\n  grupo_edad         peso_promedio\n  &lt;chr&gt;                      &lt;dbl&gt;\n1 Mayor o igual a 20          67.5\n2 Menor a 20                  65  \n\n\nExplicación: Se crea una nueva variable grupo_edad que clasifica a los estudiantes en dos categorías: “Mayor o igual a 20” y “Menor a 20”. Luego, se calcula el peso promedio para cada grupo. Este tipo de operación es útil para realizar análisis comparativos entre categorías, como estudios demográficos o segmentación de datos.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "08_manipulacion.html#uso-de-pipes-para-mejorar-la-legibilidad-del-código",
    "href": "08_manipulacion.html#uso-de-pipes-para-mejorar-la-legibilidad-del-código",
    "title": "9  Manipulación de datos con dplyr y tidyr",
    "section": "9.3 Uso de pipes (%>%) para mejorar la legibilidad del código",
    "text": "9.3 Uso de pipes (%&gt;%) para mejorar la legibilidad del código\nEl operador pipe (%&gt;%), introducido por el paquete magrittr y ampliamente adoptado en el ecosistema tidyverse, permite encadenar funciones de manera legible. En lugar de anidar funciones, el pipe pasa el resultado de una función como entrada a la siguiente.\nEjemplo sin pipes: Cuando no se utiliza el operador pipe, las funciones deben anidarse o ejecutarse en pasos separados, lo que puede dificultar la lectura y comprensión del código:\n\n# Crear columna grupo_edad usando mutate\ndatos &lt;- datos %&gt;%\n  mutate(grupo_edad = ifelse(edad &gt;= 20, \n                             \"Mayor o igual a 20\", \n                             \"Menor a 20\")) \n# Agrupar y resumir los datos sin pipes\nresultado &lt;- summarize(group_by(datos, grupo_edad),\n                       peso_promedio = mean(peso))\n\nEjemplo con pipes: El uso de pipes permite encadenar las operaciones de manera más clara y natural, eliminando la necesidad de anidar funciones:\n\n# Agrupar y resumir los datos con pipes\nresultado &lt;- datos %&gt;%   \n  group_by(grupo_edad) %&gt;%   \n  summarize(peso_promedio = mean(peso))\n\nDiferencia clave: Con pipes, el flujo de trabajo se lee de arriba hacia abajo, siguiendo un orden lógico que refleja el proceso de análisis.\n\n9.3.1 Ventajas del uso de pipes\nEl uso de pipes (%&gt;%) en R mejora significativamente la legibilidad del código al permitir que las operaciones se encadenen de manera secuencial y lógica, eliminando la necesidad de anidar funciones. Esto facilita la comprensión del flujo de trabajo, especialmente en análisis complejos. Además, los pipes simplifican la depuración, ya que dividen el análisis en pasos claros, lo que permite identificar errores y verificar resultados intermedios con mayor facilidad.\nOtra ventaja clave es la modularidad, ya que cada operación se organiza como un bloque independiente, lo que facilita realizar ajustes sin afectar el resto del análisis. Finalmente, los pipes promueven la reproducibilidad, al estructurar el código de forma clara y reutilizable, mejorando la colaboración y asegurando resultados consistentes.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "08_manipulacion.html#transformación-de-datos-con-tidyr",
    "href": "08_manipulacion.html#transformación-de-datos-con-tidyr",
    "title": "9  Manipulación de datos con dplyr y tidyr",
    "section": "9.4 Transformación de datos con tidyr",
    "text": "9.4 Transformación de datos con tidyr\nEl paquete tidyr es una herramienta fundamental para la reorganización de datos en R, especialmente cuando se necesita cambiar entre formatos “ancho” y “largo”. Esta transformación es esencial para adaptar los datos a diferentes tipos de análisis estadísticos y visualizaciones (Wickham & Grolemund, 2017).\n\n9.4.1 ¿Qué son los formatos ancho y largo?\nFormato ancho: Cada variable tiene su propia columna, y cada observación está en una sola fila.\nFormato largo: Las variables están organizadas en pares de columnas (nombre de variable y valor), con múltiples filas por observación.\n\n\n9.4.2 Funciones principales de transformación\n\npivot_longer(): se utiliza para transformar datos de formato ancho a largo. Este tipo de transformación es especialmente útil cuando se necesita trabajar con datos en los que cada observación debe ocupar una fila, mientras que las variables se representan en columnas separadas. Por ejemplo, es ideal para crear gráficos con múltiples series, ya que facilita la comparación entre diferentes variables en un mismo análisis. Además, este formato es requerido en muchos análisis estadísticos que trabajan con datos agrupados, como ANOVA o modelos de regresión, donde las variables deben estar organizadas en un formato más estructurado.\npivot_wider(): realiza la transformación inversa, es decir, convierte datos de formato largo a ancho. Este tipo de transformación es útil cuando se necesita crear tablas resumen que presenten los datos de manera más compacta y legible. También es esencial para análisis que requieren que las variables estén en columnas separadas, como cálculos de correlación o regresiones específicas. Además, el formato ancho es más adecuado para la presentación de resultados en reportes o tablas, ya que permite visualizar de forma clara las relaciones entre las variables y las observaciones.\n\n\n\n9.4.3 Ejemplo práctico\nPara ilustrar el uso de las funciones de transformación de datos, consideremos un ejemplo práctico con calificaciones de estudiantes. Inicialmente, crearemos un conjunto de datos que contiene las calificaciones de tres estudiantes en dos materias diferentes:\n\n# Crear data frame de calificaciones\ncalificaciones &lt;- data.frame(\n  nombre = c(\"Juan\", \"Ana\", \"Luis\"),\n  matematicas = c(85, 90, 78),\n  ciencias = c(88, 92, 80)\n)\n\n# Visualizar el data frame original\nprint(\"Datos originales en formato ancho:\")\n\n[1] \"Datos originales en formato ancho:\"\n\ncalificaciones\n\n  nombre matematicas ciencias\n1   Juan          85       88\n2    Ana          90       92\n3   Luis          78       80\n\n\nEn este formato, cada fila representa a un estudiante y las calificaciones de las materias están organizadas en columnas. Sin embargo, para ciertos análisis estadísticos o visualizaciones, es necesario transformar los datos a un formato largo.\n\n9.4.3.1 Transformar de formato ancho a largo\nLa función pivot_longer() permite reorganizar los datos para que cada combinación de estudiante y materia ocupe una fila independiente. Este formato es útil para análisis que requieren datos agrupados o para la creación de gráficos comparativos:\n\n# Transformar a formato largo\ncalificaciones_largo &lt;- calificaciones %&gt;%\n  pivot_longer(\n    cols = c(matematicas, ciencias),    # Columnas a transformar\n    names_to = \"materia\",               # Nueva columna para nombres de materias\n    values_to = \"calificacion\"          # Nueva columna para calificaciones\n  )\n\nprint(\"Datos en formato largo:\")\n\n[1] \"Datos en formato largo:\"\n\ncalificaciones_largo\n\n# A tibble: 6 × 3\n  nombre materia     calificacion\n  &lt;chr&gt;  &lt;chr&gt;              &lt;dbl&gt;\n1 Juan   matematicas           85\n2 Juan   ciencias              88\n3 Ana    matematicas           90\n4 Ana    ciencias              92\n5 Luis   matematicas           78\n6 Luis   ciencias              80\n\n\nEn este formato, cada fila representa una observación única de estudiante y materia, lo que facilita la comparación entre variables, el cálculo de estadísticas por grupo y la preparación de datos para visualizaciones.\n\n\n9.4.3.2 Transformar de formato largo a ancho\nCuando se requiere regresar al formato original, por ejemplo, para presentar los datos en una tabla resumen, se utiliza la función pivot_wider(). Esta función reorganiza los datos para que las materias vuelvan a ocupar columnas separadas:\n\n# Transformar de vuelta a formato ancho\ncalificaciones_ancho &lt;- calificaciones_largo %&gt;%\n  pivot_wider(\n    names_from = \"materia\",            # Columna que se convertirá en nombres de columnas\n    values_from = \"calificacion\"       # Columna que contiene los valores\n  )\n\nprint(\"Datos restaurados en formato ancho:\")\n\n[1] \"Datos restaurados en formato ancho:\"\n\ncalificaciones_ancho\n\n# A tibble: 3 × 3\n  nombre matematicas ciencias\n  &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 Juan            85       88\n2 Ana             90       92\n3 Luis            78       80\n\n\nEsta transformación permite restaurar el formato original, donde cada estudiante ocupa una fila y las materias están organizadas en columnas. Este formato es adecuado para reportes, análisis que requieren variables en columnas independientes o para la presentación de datos de manera más legible.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "09_visualizacion.html",
    "href": "09_visualizacion.html",
    "title": "12  Visualización de datos con ggplot2",
    "section": "",
    "text": "12.1 Contexto de la base de datos utilizada\nLa visualización de datos es una herramienta esencial en el análisis estadístico, ya que permite explorar patrones, identificar relaciones y comunicar resultados de manera efectiva. En R, el paquete ggplot2 es ampliamente reconocido por su flexibilidad y capacidad para generar gráficos de alta calidad. Este capítulo aborda los conceptos básicos de ggplot2, la creación de gráficos comunes y las opciones de personalización disponibles, utilizando como ejemplo un conjunto de datos recopilado en un estudio realizado en la Universidad de San Carlos de Guatemala en 2002.\nEl estudio mencionado recopiló información de 460 estudiantes de diversas facultades, incluyendo variables como facultad, edad, sexo, estado civil, jornada de estudio, año de ingreso, peso, talla y hábitos como fumar o consumo de alcohol. Este conjunto de datos, disponible en formato CSV, será utilizado para ilustrar las herramientas y conceptos desarrollados en esta sección. El archivo puede descargarse desde el siguiente repositorio: GitHub - Visualización de datos.\nNota: Es necesario descargar el archivo y guardarlo en la carpeta correspondiente al proyecto en curso para ejecutar los ejemplos.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "09_visualizacion.html#introducción-al-paquete-ggplot2",
    "href": "09_visualizacion.html#introducción-al-paquete-ggplot2",
    "title": "12  Visualización de datos con ggplot2",
    "section": "12.2 Introducción al paquete ggplot2",
    "text": "12.2 Introducción al paquete ggplot2\nEl paquete ggplot2 es una herramienta versátil y poderosa para la visualización de datos en R. Su diseño modular basado en capas permite construir gráficos de calidad profesional, adaptándose tanto a visualizaciones simples como a gráficos complejos. Además, su integración con el ecosistema tidyverse facilita los flujos de trabajo al combinarse con herramientas como dplyr y tidyr para la manipulación de datos (Wickham, 2016).\nEntre las principales características de ggplot2 se encuentran:\n\nFlexibilidad: Compatible con una amplia variedad de tipos de gráficos, como gráficos de barras, líneas, puntos, histogramas y diagramas de cajas.\nPersonalización: Permite ajustar elementos como colores, etiquetas, temas y escalas.\nExtensibilidad: Puede ampliarse mediante paquetes adicionales, como ggthemes para temas personalizados o plotly para gráficos interactivos.\nComunidad activa: Su extensa documentación y comunidad de usuarios facilitan el aprendizaje y la resolución de problemas.\n\n\n12.2.1 Estructura básica de un gráfico en ggplot2\nLa creación de gráficos en ggplot2 sigue una estructura modular que permite construir visualizaciones de manera flexible y escalable. La sintaxis general es la siguiente:\n\nggplot(data = DATOS, aes(x = VARIABLE_X, y = VARIABLE_Y)) +\n  GEOM_FUNCION() +\n  labs(title = \"Título del gráfico\",\n       x = \"Etiqueta eje X\",\n       y = \"Etiqueta eje Y\")\n\nComponentes principales:\n\ndata: Este argumento define el conjunto de datos que se utilizará para construir el gráfico. Debe ser un data frame o un objeto compatible con este formato. Es el punto de partida para cualquier visualización, ya que contiene las variables que se representarán gráficamente.\naes(): La función aes() (abreviatura de aesthetics) especifica el mapeo estético, es decir, cómo las variables del conjunto de datos se asignan a los elementos visuales del gráfico. Algunos de los mapeos más comunes incluyen:\nx: Variable asignada al eje horizontal.\ny: Variable asignada al eje vertical.\ncolor: Variable que define el color de los elementos.\nsize: Variable que define el tamaño de los elementos.\nshape: Variable que define la forma de los puntos (en gráficos de dispersión, por ejemplo).\nfill: Variable que define el color de relleno (en gráficos como barras o áreas).\nGEOM_FUNCION(): La función geométrica (geom_) define el tipo de gráfico que se desea crear. Cada tipo de gráfico tiene su propia función en ggplot2, como:\ngeom_point(): Gráfico de puntos (dispersión).\ngeom_bar(): Gráfico de barras.\ngeom_line(): Gráfico de líneas.\ngeom_histogram(): Histograma.\ngeom_boxplot(): Diagrama de cajas (boxplot).\nlabs(): La función labs() se utiliza para añadir etiquetas y títulos al gráfico. Esto incluye:\ntitle: Título principal del gráfico.\nx: Etiqueta del eje X.\ny: Etiqueta del eje Y.\nsubtitle: Subtítulo del gráfico.\ncaption: Texto adicional, como la fuente de los datos.\nOperador +: El operador + es fundamental en ggplot2, ya que permite combinar diferentes capas (layers) en un gráfico. Cada capa puede añadir elementos adicionales, como líneas de tendencia, etiquetas o temas personalizados.\n\nPersonalización adicional:\nAdemás de los elementos básicos, ggplot2 permite personalizar los gráficos mediante:\n\nTemas: La función theme() ajusta el diseño general del gráfico, como el tamaño de las fuentes, los colores de fondo y la posición de las leyendas.\nEscalas: Las funciones scale_ permiten modificar los colores, tamaños y formas de los elementos gráficos.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "09_visualizacion.html#creación-de-gráficos-básicos",
    "href": "09_visualizacion.html#creación-de-gráficos-básicos",
    "title": "12  Visualización de datos con ggplot2",
    "section": "12.3 Creación de gráficos básicos",
    "text": "12.3 Creación de gráficos básicos\nA continuación, se presentan ejemplos de gráficos comunes que se pueden crear con ggplot2, junto con su sintaxis y una explicación detallada. Antes de proceder con la creación de gráficos, es fundamental importar la base de datos y cargar los paquetes necesarios. A continuación, se muestra cómo realizar estos pasos:\n\n12.3.1 Importación de la base de datos\n\n# Ejemplo práctico: Uso de paquetes para visualización\n# NOTA: Antes de trabajar, es necesario crear y guardar un nuevo script.\n\n# Instalación y carga de paquetes esenciales\n\n# Paquete que incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Paquete para establecer el directorio de trabajo automáticamente\nif (!require(\"rstudioapi\")) install.packages(\"rstudioapi\")\n\n# Importar la base de datos\ndatos &lt;- read_csv(\"datos_estudiantes.csv\")\n\n# Ver las primeras filas del conjunto de datos\nhead(datos)\n\nExplicación del código:\n\nInstalación y carga de paquetes: Se utiliza la función if (!require (...)) para verificar si los paquetes están instalados. Si no lo están, se instalan automáticamente con install.packages(). Automáticamente, se cargan. El paquete tidyverse incluye herramientas esenciales para la manipulación y visualización de datos, como ggplot2, dplyr y tidyr. El paquete rstudioapi permite establecer el directorio de trabajo automáticamente, lo que facilita la organización de los archivos.\nEstablecimiento del directorio de trabajo: La función setwd() establece el directorio de trabajo en la ubicación del script actual, utilizando rstudioapi::getActiveDocumentContext()$path. Esto asegura que los archivos se encuentren en la misma carpeta que el script, mejorando la reproducibilidad.\nImportación de datos: La función read_csv() del paquete readr se utiliza para leer archivos CSV. La función head() permite visualizar las primeras filas del conjunto de datos, proporcionando una vista previa de su estructura.\n\n\n12.3.1.1 Notas importantes\n\nEs fundamental asegurarse de que el archivo datos_estudiantes.csv esté ubicado en el directorio de trabajo establecido.\nSi el archivo no se encuentra en el directorio especificado, se generará un error. En ese caso, se puede verificar la ubicación del archivo con getwd() o establecer manualmente el directorio con setwd(\"ruta/del/directorio\").\n\n\n\n\n12.3.2 Histogramas\nLos histogramas son gráficos que permiten visualizar la distribución de una variable numérica, mostrando cómo se agrupan los valores en intervalos específicos. Son útiles para identificar patrones, como la simetría, la dispersión, la presencia de valores atípicos o la forma general de la distribución (e.g., normal, sesgada, etc.).\n\n12.3.2.1 Ejemplo práctico: Creación de un histograma\nEl siguiente código muestra cómo crear un histograma utilizando ggplot2 para explorar la distribución del peso de los estudiantes:\n\n# Ejemplo práctico: Creación de un histograma\nggplot(data = datos, aes(x = PESO_lbs)) +\n  geom_histogram(binwidth = 5, fill = \"skyblue\", color = \"black\") +\n  labs(title = \"Distribución del peso de los estudiantes\",\n       x = \"Peso (libras)\",\n       y = \"Frecuencia\")\n\n\n\n\n\n\n\n\nExplicación del código:\n\nggplot(data = datos, aes(x = PESO_lbs)): Se define el conjunto de datos (datos) y se especifica la variable numérica que se desea analizar (PESO_lbs) dentro de la función aes(). Esta variable se asigna al eje X, ya que el histograma representa la frecuencia de los valores en este eje.\ngeom_histogram(): Esta función geométrica es la encargada de crear el histograma. Cada barra representa la frecuencia de los valores que caen dentro de un intervalo específico.\nArgumento binwidth: El parámetro binwidth define el ancho de los intervalos (o “bins”) en los que se agrupan los datos. En este caso, se establece un ancho de 5 unidades, lo que significa que cada barra del histograma abarca un rango de 5 libras.\nUn valor más pequeño de binwidth genera más barras, proporcionando mayor detalle, mientras que un valor más grande agrupa los datos en menos barras, mostrando una visión más general.\nArgumentos fill y color:\nfill: Define el color de relleno de las barras. En este ejemplo, se utiliza el color “skyblue” para un diseño visualmente atractivo.\ncolor: Define el color del borde de las barras, que en este caso es negro (“black”). Esto ayuda a diferenciar claramente las barras entre sí.\nlabs(): La función labs() se utiliza para añadir etiquetas descriptivas al gráfico:\ntitle: Título principal del gráfico, que describe el propósito del histograma.\nx: Etiqueta del eje X, que indica la variable representada (en este caso, el peso en libras).\ny: Etiqueta del eje Y, que muestra la frecuencia de los valores.\n\n\n\n\n12.3.3 Gráficos de barras\nLos gráficos de barras son ideales para representar datos categóricos, mostrando la frecuencia o el conteo de observaciones en cada categoría. Este tipo de gráfico es útil para comparar grupos o categorías de manera visual y sencilla.\n\n12.3.3.1 Ejemplo práctico: Creación de un gráfico de barras\nEl siguiente código muestra cómo crear un gráfico de barras utilizando ggplot2 para analizar la distribución de estudiantes según su jornada:\n\n# Ejemplo práctico: Creación de un gráfico de barras\nggplot(data = datos, aes(x = JORNADA)) +\n  geom_bar(fill = \"orange\", color = \"black\") +\n  labs(title = \"Distribución de estudiantes por jornada\",\n       x = \"Jornada\",\n       y = \"Frecuencia\")\n\n\n\n\n\n\n\n\nExplicación del código:\n\nggplot(data = datos, aes(x = JORNADA)): Se define el conjunto de datos (datos) y se especifica la variable categórica JORNADA dentro de la función aes(). Esta variable se asigna al eje X, ya que el gráfico de barras representa las categorías en este eje.\ngeom_bar(): Esta función geométrica genera el gráfico de barras. Por defecto, geom_bar() cuenta automáticamente las observaciones en cada categoría de la variable especificada en el eje X.\nArgumentos fill y color:\nfill: Define el color de relleno de las barras. En este ejemplo, se utiliza el color “orange” para un diseño llamativo.\ncolor: Define el color del borde de las barras, que en este caso es negro (“black”). Esto ayuda a resaltar las barras y separarlas visualmente.\n\n\n\n\n12.3.4 Gráficos de dispersión (scatterplots)\nLos gráficos de dispersión son herramientas visuales que permiten analizar la relación entre dos variables numéricas. Cada punto en el gráfico representa una observación, donde la posición en el eje X corresponde al valor de una variable y la posición en el eje Y al valor de la otra. Este tipo de gráfico es útil para identificar patrones, tendencias, correlaciones y posibles valores atípicos.\n\n12.3.4.1 Ejemplo práctico: Creación de un gráfico de dispersión\nEl siguiente código muestra cómo crear un gráfico de dispersión utilizando ggplot2 para explorar la relación entre la talla y el peso de los estudiantes:\n\n# Ejemplo práctico: Creación de un gráfico de dispersión\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point(color = \"red\", size = 2) +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\n\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)): Se define el conjunto de datos (datos) y se especifican las variables numéricas que se desean analizar:\nTALLA: Variable asignada al eje X (talla en metros).\nPESO_lbs: Variable asignada al eje Y (peso en libras).\ngeom_point(): Esta función geométrica dibuja los puntos en el gráfico, representando cada observación del conjunto de datos.\nArgumentos color y size:\ncolor: Define el color de los puntos. En este ejemplo, los puntos se dibujan en rojo (“red”).\nsize: Define el tamaño de los puntos. Aquí se establece un tamaño de 2 para que los puntos sean más visibles.\n\n\n\n\n12.3.5 Boxplots\nLos boxplots (o diagramas de caja y bigotes) son gráficos que permiten visualizar la distribución de una variable numérica y compararla entre diferentes grupos categóricos. Este tipo de gráfico es útil para identificar la mediana, la dispersión, los valores atípicos y la simetría de los datos dentro de cada grupo.\n\n12.3.5.1 Ejemplo práctico: Creación de un boxplot\nEl siguiente código muestra cómo crear un boxplot utilizando ggplot2 para analizar la distribución del peso de los estudiantes según su sexo:\n\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)) +\n  geom_boxplot() +\n  labs(title = \"Distribución del peso por sexo\",\n       x = \"Sexo\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\nExplicación del código\n\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)): Se define el conjunto de datos (datos) y se especifican las variables:\nSEXO: Variable categórica asignada al eje X, que define los grupos a comparar.\nPESO_lbs: Variable numérica asignada al eje Y, cuya distribución se analiza dentro de cada grupo.\nfill: Argumento opcional que asigna un color de relleno diferente a cada grupo basado en la variable SEXO.\ngeom_boxplot(): Esta función geométrica genera el boxplot. Cada caja representa la distribución de la variable numérica dentro de un grupo categórico.\n\n\n\n12.3.5.2 Elementos clave de un boxplot\nUn boxplot incluye los siguientes elementos visuales:\n\nCaja (box): Representa el rango intercuartílico (IQR), que abarca del primer cuartil (Q1) al tercer cuartil (Q3).\nLínea dentro de la caja: Indica la mediana de los datos.\nBigotes (whiskers): Extienden los valores hasta 1.5 veces el IQR desde los cuartiles Q1 y Q3.\nPuntos fuera de los bigotes: Representan valores atípicos (outliers), que están fuera del rango esperado.\n\n\n\n\n12.3.6 Gráfico de líneas\nLos gráficos de líneas son ideales para visualizar tendencias a lo largo del tiempo o en secuencias de datos ordenados. Este tipo de gráfico es especialmente útil para identificar patrones, como aumentos, disminuciones o fluctuaciones en los datos.\n\n12.3.6.1 Ejemplo práctico: Creación de un gráfico de líneas\nEl siguiente código muestra cómo crear un gráfico de líneas utilizando ggplot2 para visualizar la cantidad de estudiantes encuestados por año de ingreso:\n\n# Crear un gráfico de líneas de estudiantes por año de ingreso\nggplot(data = datos, aes(x = AÑO_ING)) +\n  geom_line(stat = \"count\", color = \"darkblue\", linewidth = 1.2) +\n  geom_point(stat = \"count\", color = \"darkred\", size = 3) +\n  labs(title = \"Estudiantes encuestados por año de ingreso\",\n       subtitle = \"Universidad de San Carlos de Guatemala (2002)\",\n       x = \"Año de ingreso\",\n       y = \"Número de estudiantes\") \n\n\n\n\n\n\n\n\nExplicación del código\n\nggplot(data = datos, aes(x = AÑO_ING)): Se define el conjunto de datos (datos) y se especifica la variable AÑO_ING como el eje X, que representa los años de ingreso de los estudiantes. En este caso, no se especifica una variable para el eje Y, ya que el conteo de estudiantes por año se calcula automáticamente con stat = \"count\".\ngeom_line(stat = “count”, color = “darkblue”, linewidth = 1.2): La función geom_line() genera la línea que conecta los puntos correspondientes al conteo de estudiantes por año.\nstat = \"count\" indica que se debe contar automáticamente el número de observaciones en cada categoría del eje X.\ncolor: Define el color de la línea (en este caso, azul oscuro).\nlinewidth: Ajusta el grosor de la línea (1.2 en este ejemplo).\ngeom_point(stat = “count”, color = “darkred”, size = 3): La función geom_point() añade puntos en cada categoría del eje X, representando el conteo de estudiantes.\nstat = \"count\" asegura que los puntos correspondan al conteo calculado.\ncolor: Define el color de los puntos (en este caso, rojo oscuro).\nsize: Ajusta el tamaño de los puntos (3 en este ejemplo).",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "09_visualizacion.html#personalización-de-gráficos",
    "href": "09_visualizacion.html#personalización-de-gráficos",
    "title": "12  Visualización de datos con ggplot2",
    "section": "12.4 Personalización de gráficos",
    "text": "12.4 Personalización de gráficos\nLa personalización de gráficos en ggplot2 permite adaptarlos a diferentes necesidades, mejorando tanto su presentación como su capacidad para comunicar información de manera efectiva. A continuación, se describen algunas de las opciones más comunes, comenzando con la personalización de colores.\n\n12.4.1 Personalización de colores\nEn ggplot2, es posible modificar los colores de los elementos del gráfico, como puntos, barras o líneas, para destacar información clave o mejorar la estética general. Esto se puede lograr utilizando argumentos como color (para bordes o contornos) y fill (para colores de relleno).\n\n12.4.1.1 Personalización de colores en un gráfico de dispersión\nEl siguiente código muestra cómo personalizar el color de los puntos en un gráfico de dispersión:\n\n# Personalización de colores en un gráfico de dispersión\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point(color = \"darkgreen\", size = 2) +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\ncolor = \"darkgreen\" define el color de los puntos como verde oscuro.\nsize = 2 ajusta el tamaño de los puntos para mejorar su visibilidad.\n\n\n\n12.4.1.2 Personalización de colores por grupo\nSi se desea asignar colores diferentes a los puntos según una variable categórica, se puede incluir el argumento color dentro de aes():\n\n# Personalización de colores por grupo\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs, color = SEXO)) +\n  geom_point(size = 2) +\n  labs(title = \"Relación entre talla y peso por sexo\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\",\n       color = \"Sexo\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nLos puntos se colorean automáticamente según los valores de la variable SEXO.\nLa leyenda se genera de forma automática para indicar el significado de los colores.\n\n\n\n12.4.1.3 Personalización de colores en gráficos con relleno\nEn gráficos como barras o boxplots, se utiliza el argumento fill para personalizar el color de relleno:\n\n# Personalización de colores en gráficos con relleno\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)) +\n  geom_boxplot() +\n  labs(title = \"Distribución del peso por sexo\",\n       x = \"Sexo\",\n       y = \"Peso (libras)\",\n       fill = \"Sexo\")\n\n\n\n\n\n\n\n\nEn este ejemplo, las cajas del boxplot se rellenan con colores diferentes según la variable SEXO.\n\n\n12.4.1.4 Escalas de color personalizadas\nPara un mayor control sobre los colores, se pueden definir escalas personalizadas utilizando funciones como scale_color_manual() o scale_fill_manual():\n\n# Escalas de color personalizadas\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)) +\n  geom_boxplot() +\n  scale_fill_manual(values = c(  \"pink\", \"lightblue\")) +\n  labs(title = \"Distribución del peso por sexo\",\n       x = \"Sexo\",\n       y = \"Peso (libras)\",\n       fill = \"Sexo\")\n\n\n\n\n\n\n\n\nEn este ejemplo, se asignan colores específicos a cada categoría de la variable SEXO, R realiza la realiza la asignación de los colores de la escala en orden alfabético de las variables categóricas.\n\n\n\n12.4.2 Etiquetas y títulos\nEn ggplot2, es posible añadir y personalizar títulos, subtítulos y etiquetas de los ejes para mejorar la claridad y presentación de los gráficos. Estas etiquetas ayudan a contextualizar la información y a facilitar su interpretación.\n\n12.4.2.1 Personalización de títulos y etiquetas\nLa función labs() se utiliza para añadir y personalizar los siguientes elementos:\n\ntitle: Título principal del gráfico, que describe su propósito o contenido.\nsubtitle: Subtítulo que proporciona información adicional o contexto.\nx: Etiqueta del eje X, que describe la variable representada en este eje.\ny: Etiqueta del eje Y, que describe la variable representada en este eje.\ncaption (opcional): Texto adicional, como la fuente de los datos o notas aclaratorias.\n\n\n\n12.4.2.2 Añadir subtítulos y etiquetas personalizadas\nEl siguiente código muestra cómo personalizar títulos, subtítulos y etiquetas de los ejes en un gráfico de dispersión:\n\n# Añadir subtítulos y etiquetas personalizadas\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  labs(title = \"Relación entre talla y peso\",\n       subtitle = \"Datos del estudio de 2002\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\",\n       caption = \"Fuente: Base de datos de estudiantes\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\ntitle añade un título descriptivo al gráfico.\nsubtitle proporciona contexto adicional, como el año del estudio.\nx y y personalizan las etiquetas de los ejes, indicando las unidades de medida.\ncaption incluye una nota al pie con la fuente de los datos.\n\n\n\n12.4.2.3 Ajuste de la posición y estilo de los títulos\nSe puede personalizar la posición, tamaño y estilo de los títulos utilizando la función theme():\n\n# Ajuste de la posición y estilo de los títulos\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  labs(title = \"Relación entre talla y peso\",\n       subtitle = \"Datos del estudio de 2002\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\") +\n  theme(plot.title = element_text(hjust = 0.5, \n                                  size = 16, \n                                  face = \"bold\"),\n        plot.subtitle = element_text(hjust = 0.5, \n                                     size = 12, \n                                     face = \"italic\"))\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nhjust = 0.5 centra el título y el subtítulo.\nsize ajusta el tamaño del texto.\nface define el estilo del texto (\"bold\" para negrita, \"italic\" para cursiva).\n\n\n\n12.4.2.4 Rotación de etiquetas en los ejes\nSi las etiquetas del eje X son largas o numerosas, se pueden rotar para mejorar la legibilidad:\n\n# Rotación de etiquetas en los ejes\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\") +\n  theme(axis.text.y = element_text(angle = 90, hjust = 0.5))\n\n\n\n\n\n\n\n\nEn este ejemplo, las etiquetas del eje Y se rotan 90 grados.\n\n\n\n12.4.3 Temas\nEn ggplot2, los temas permiten modificar el estilo general de un gráfico, ajustando elementos como el fondo, las líneas de los ejes, las fuentes y la disposición de los textos. Esto facilita la creación de gráficos con un diseño coherente y adaptado a diferentes propósitos, como presentaciones, informes o publicaciones.\n\n12.4.3.1 Aplicación de temas predefinidos\nggplot2 incluye varios temas predefinidos que se pueden aplicar directamente para cambiar el estilo del gráfico. Algunos de los más comunes son:\n\ntheme_minimal(): Un diseño limpio y moderno, con un fondo blanco y líneas simples.\ntheme_classic(): Un estilo clásico con líneas de ejes visibles y sin cuadrícula.\ntheme_light(): Similar a theme_minimal(), pero con cuadrículas más visibles.\ntheme_dark(): Un diseño con fondo oscuro, ideal para presentaciones.\ntheme_void(): Un gráfico sin ejes ni cuadrículas, útil para gráficos personalizados.\n\n\n\n12.4.3.2 Ejemplo: Aplicar un tema minimalista\nEl siguiente código muestra cómo aplicar el tema theme_minimal() a un gráfico de dispersión:\n\n# Ejemplo: Aplicar un tema minimalista\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\nEn este ejemplo: theme_minimal() elimina elementos innecesarios, como bordes y fondos grises, dejando un diseño limpio y profesional.\n\n\n12.4.3.3 Ejemplo: personalización de temas\nAdemás de los temas predefinidos, es posible personalizar elementos específicos del gráfico utilizando la función theme(). Por ejemplo:\n\n# Personalización de temas\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\"),\n    axis.text = element_text(size = 12),\n    axis.title = element_text(size = 14, face = \"italic\"),\n    panel.grid.major = element_line(color = \"gray\", linetype = \"dashed\")\n  ) +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nplot.title centra el título y ajusta su tamaño y estilo.\naxis.text y axis.title modifican el tamaño y estilo de las etiquetas de los ejes.\npanel.grid.major personaliza las líneas de la cuadrícula principal, cambiando su color y estilo.\n\n\n\n\n12.4.4 Facetas\nLas facetas en ggplot2 permiten dividir un gráfico en múltiples subgráficos basados en los valores de una variable categórica. Esto es especialmente útil para comparar patrones o relaciones entre diferentes grupos dentro de un conjunto de datos, manteniendo la coherencia visual.\n\n12.4.4.1 Ejemplo: relación entre talla y peso por facultad\nEl siguiente código muestra cómo utilizar facetas para analizar la relación entre talla y peso, separando los datos por facultad:\n\n# Ejemplo: relación entre talla y peso por facultad\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  facet_wrap(~ FACULTAD) +\n  labs(title = \"Relación entre talla y peso por facultad\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nfacet_wrap(~ FACULTAD) divide el gráfico en subgráficos, uno para cada valor único de la variable FACULTAD.\nCada subgráfico muestra la relación entre TALLA y PESO_lbs para una facultad específica.\n\n\n\n\n12.4.5 Ejemplo avanzado de personalización\nLa flexibilidad y la lógica de capas de ggplot2 permiten crear gráficos con un alto grado de personalización, adaptados a necesidades específicas y con un diseño profesional. A continuación, se presenta un ejemplo de un gráfico de barras con personalización detallada:\n\n# Ejemplo avanzado de personalización\nggplot(data = datos, aes(x = FACULTAD)) +\n  geom_bar(fill = \"steelblue\", color = \"black\", alpha = 0.8) +\n  labs(\n    title = \"Distribución de estudiantes por facultad\",\n    subtitle = \"Datos del estudio de 2002, USAC\",\n    x = \"Facultad\",\n    y = \"Cantidad de estudiantes\",\n    caption = \"Fuente: Estudio realizado en 2002\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 12, hjust = 0.5, color = \"gray50\"),\n    axis.title = element_text(size = 12, face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.caption = element_text(hjust = 0, size = 8, color = \"gray50\")\n  )\n\n\n\n\n\n\n\n\n\n12.4.5.1 Explicación del código\n\nDatos y mapeo estético: aes(x = FACULTAD): Se utiliza la variable FACULTAD directamente desde la base de datos para el eje X.\nGráfico de barras: geom_bar(): Genera automáticamente las barras basándose en la frecuencia de cada categoría. En el ejemplo se utilizaron los siguientes argumentos:\nfill = \"steelblue\": Define el color de relleno de las barras como azul acero.\ncolor = \"black\": Establece el color de los bordes de las barras en negro.\nalpha = 0.8: Ajusta la transparencia de las barras, permitiendo un diseño más suave.\nEtiquetas y títulos: labs(): Añade un título principal, subtítulo, etiquetas para los ejes y una nota al pie con la fuente de los datos.\nTema profesional: theme_minimal(): Aplica un diseño limpio y moderno.\nPersonalización específica: theme(): Personaliza elementos específicos del gráfico empleando los siguiente argumentos:\nplot.title: Ajusta el tamaño, estilo (negrita) y posición (centrado) del título.\nplot.subtitle: Cambia el tamaño, posición y color del subtítulo.\naxis.title: Modifica el tamaño y estilo de las etiquetas de los ejes.\naxis.text.x: Rota las etiquetas del eje X 45 grados para mejorar la legibilidad, especialmente si las categorías tienen nombres largos.\npanel.grid.major.x y panel.grid.minor: Elimina las líneas de cuadrícula verticales y menores para un diseño más limpio.\nplot.caption: Ajusta el tamaño, posición y color de la nota al pie.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "10_exportacion.html",
    "href": "10_exportacion.html",
    "title": "13  Exportación de resultados",
    "section": "",
    "text": "13.1 La función ggsave()\nLa exportación de resultados es una etapa crucial en el análisis de datos, ya que permite guardar gráficos y tablas para su uso en informes, presentaciones o análisis posteriores. En esta sección, se detalla cómo guardar gráficos en formatos PNG y PDF utilizando la función ggsave() del paquete ggplot2, y cómo exportar tablas en formatos CSV y Excel utilizando las funciones write.csv() y write_xlsx() del paquete writexl. Estas herramientas son esenciales para garantizar que los resultados del análisis sean accesibles y reutilizables (R Core Team, 2023; Wickham, 2016).\nLa función ggsave() pertenece al paquete ggplot2 y se utiliza para guardar gráficos en diferentes formatos de archivo, como PNG, PDF, JPEG, entre otros. Es una herramienta versátil que permite personalizar aspectos como el tamaño, la resolución y el formato del archivo de salida (Wickham, 2016).\nLa sintaxis general de la función es la siguiente:\nggsave(\n  filename,\n  plot = last_plot(),\n  device = NULL,\n  path = NULL,\n  scale = 1,\n  width = NA,\n  height = NA,\n  units = c(\"in\", \"cm\", \"mm\"),\n  dpi = 300,\n  limitsize = TRUE)\nDescripción de los argumentos principales:\n1. filename: Este argumento es obligatorio y define el nombre del archivo de salida, incluyendo su extensión (por ejemplo, \"grafico.png\" o \"grafico.pdf\"). La extensión del archivo determina automáticamente el formato en el que se guardará el gráfico, a menos que se especifique explícitamente con el argumento device. Es importante asegurarse de que el nombre del archivo sea válido para el sistema operativo utilizado.\n2. plot: Este argumento opcional permite especificar el gráfico que se desea guardar. Si no se proporciona, ggsave() guardará automáticamente el último gráfico creado en la sesión de R, utilizando la función last_plot(). Esto es útil para flujos de trabajo interactivos, pero en proyectos más complejos se recomienda asignar los gráficos a objetos para evitar confusiones.\n3. device: El argumento device define el tipo de dispositivo o formato del archivo de salida, como \"png\", \"pdf\", \"jpeg\", entre otros. Si no se especifica, el formato se deduce automáticamente a partir de la extensión del archivo en filename. Este argumento es útil cuando se desea guardar un archivo con un formato específico, independientemente de la extensión.\n4. path: Este argumento opcional permite especificar el directorio donde se guardará el archivo. Si no se proporciona, el archivo se guardará en el directorio de trabajo actual. Es especialmente útil para organizar los gráficos en carpetas específicas dentro de un proyecto.\n5. scale: El argumento scale ajusta el tamaño del gráfico multiplicando las dimensiones especificadas en width y height por el valor proporcionado. Por defecto, su valor es 1, lo que significa que no se aplica escalado. Un valor mayor que 1 aumenta el tamaño del gráfico, mientras que un valor menor lo reduce.\n6. width y height: Estos argumentos definen el ancho y la altura del gráfico en las unidades especificadas por el argumento units. Si no se proporcionan, se utilizan las dimensiones predeterminadas del gráfico. Es importante ajustar estas dimensiones para garantizar que el gráfico se adapte correctamente al formato de salida.\n7. units: El argumento units especifica las unidades de medida para width y height. Los valores posibles son \"in\" (pulgadas), \"cm\" (centímetros) y \"mm\" (milímetros). Por defecto, se utilizan pulgadas (\"in\"), pero se pueden cambiar según las necesidades del proyecto.\n8. dpi: El argumento dpi (dots per inch) define la resolución del gráfico, siendo relevante para formatos rasterizados como PNG, JPEG o TIFF. Su valor predeterminado es 300, adecuado para impresión. Para gráficos destinados a la web, se puede utilizar un valor menor, como 72.\n9. limitsize: Este argumento controla si se permite guardar gráficos con dimensiones excesivamente grandes (mayores a 50 pulgadas). Si se establece en TRUE (valor predeterminado), se genera un error al intentar guardar gráficos grandes. Para desactivar esta restricción, se debe establecer en FALSE.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Exportación de resultados</span>"
    ]
  },
  {
    "objectID": "10_exportacion.html#guardar-gráficos-con-ggsave",
    "href": "10_exportacion.html#guardar-gráficos-con-ggsave",
    "title": "11  Exportación de resultados",
    "section": "",
    "text": "11.1.1 Sintaxis General de la Función ggsave()\nLa sintaxis general de la función es la siguiente:\n\nggsave(\n  filename,\n  plot = last_plot(),\n  device = NULL,\n  path = NULL,\n  scale = 1,\n  width = NA,\n  height = NA,\n  units = c(\"in\", \"cm\", \"mm\"),\n  dpi = 300,\n  limitsize = TRUE)\n\nDescripción de los argumentos principales:\n1. filename: Este argumento es obligatorio y define el nombre del archivo de salida, incluyendo su extensión (por ejemplo, \"grafico.png\" o \"grafico.pdf\"). La extensión del archivo determina automáticamente el formato en el que se guardará el gráfico, a menos que se especifique explícitamente con el argumento device. Es importante asegurarse de que el nombre del archivo sea válido para el sistema operativo utilizado.\n2. plot: Este argumento opcional permite especificar el gráfico que se desea guardar. Si no se proporciona, ggsave() guardará automáticamente el último gráfico creado en la sesión de R, utilizando la función last_plot(). Esto es útil para flujos de trabajo interactivos, pero en proyectos más complejos se recomienda asignar los gráficos a objetos para evitar confusiones.\n3. device: El argumento device define el tipo de dispositivo o formato del archivo de salida, como \"png\", \"pdf\", \"jpeg\", entre otros. Si no se especifica, el formato se deduce automáticamente a partir de la extensión del archivo en filename. Este argumento es útil cuando se desea guardar un archivo con un formato específico, independientemente de la extensión.\n4. path: Este argumento opcional permite especificar el directorio donde se guardará el archivo. Si no se proporciona, el archivo se guardará en el directorio de trabajo actual. Es especialmente útil para organizar los gráficos en carpetas específicas dentro de un proyecto.\n5. scale: El argumento scale ajusta el tamaño del gráfico multiplicando las dimensiones especificadas en width y height por el valor proporcionado. Por defecto, su valor es 1, lo que significa que no se aplica escalado. Un valor mayor que 1 aumenta el tamaño del gráfico, mientras que un valor menor lo reduce.\n6. width y height: Estos argumentos definen el ancho y la altura del gráfico en las unidades especificadas por el argumento units. Si no se proporcionan, se utilizan las dimensiones predeterminadas del gráfico. Es importante ajustar estas dimensiones para garantizar que el gráfico se adapte correctamente al formato de salida.\n7. units: El argumento units especifica las unidades de medida para width y height. Los valores posibles son \"in\" (pulgadas), \"cm\" (centímetros) y \"mm\" (milímetros). Por defecto, se utilizan pulgadas (\"in\"), pero se pueden cambiar según las necesidades del proyecto.\n8. dpi: El argumento dpi (dots per inch) define la resolución del gráfico, siendo relevante para formatos rasterizados como PNG, JPEG o TIFF. Su valor predeterminado es 300, adecuado para impresión. Para gráficos destinados a la web, se puede utilizar un valor menor, como 72.\n9. limitsize: Este argumento controla si se permite guardar gráficos con dimensiones excesivamente grandes (mayores a 50 pulgadas). Si se establece en TRUE (valor predeterminado), se genera un error al intentar guardar gráficos grandes. Para desactivar esta restricción, se debe establecer en FALSE.\n\n\n11.1.2 Guardar en formatos PDF y PNG\nSi no se especifica el argumento plot, la función ggsave() guardará automáticamente el último gráfico creado en la sesión de R. Esto es útil cuando se trabaja de manera interactiva y se desea guardar rápidamente un gráfico sin asignarlo a un objeto. A continuación, se describen los pasos para exportar gráficos en formatos PNG y PDF, junto con ejemplos prácticos.\nCrear un gráfico con ggplot2\nAntes de guardar un gráfico, es necesario crearlo. A continuación, se presenta un ejemplo de un gráfico creado con ggplot2:\n\n# Instalación y carga de paquetes esenciales\n\n# Paquete que incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Importar la base de datos\ndatos &lt;- read_csv(\"datos_estudiantes.csv\")\n\n# Ejemplo avanzado de personalización de un gráfico\nplot&lt;- ggplot(data = datos, aes(x = FACULTAD)) +\n  geom_bar(fill = \"steelblue\", color = \"black\", alpha = 0.8) +\n  labs(\n    title = \"Distribución de estudiantes por facultad\",\n    subtitle = \"Datos del estudio de 2002, \n    Universidad de San Carlos de Guatemala\",\n    x = \"Facultad\",\n    y = \"Cantidad de estudiantes\",\n    caption = \"Fuente: Estudio realizado en 2002\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 12, hjust = 0.5, color = \"gray50\"),\n    axis.title = element_text(size = 12, face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.caption = element_text(hjust = 0, size = 8, color = \"gray50\")\n  )\n\n\n11.1.2.1 Guardar el gráfico en formato PNG\nUna vez creado el gráfico, se puede guardar utilizando ggsave():\n\n# Guardar el gráfico en formato PNG\nggsave(\"grafico.png\", width = 8, height = 6, dpi = 300)\n\n\nfilename: Nombre del archivo de salida (en este caso, \"grafico.png\").\nplot: Objeto del gráfico que se desea guardar.\nwidth y height: Dimensiones del gráfico en pulgadas.\ndpi: Resolución del archivo en puntos por pulgada (300 dpi es adecuado para impresión).\n\n\n\n11.1.2.2 Guardar en Formato PDF\nEl formato PDF es ideal para gráficos que requieren escalado sin pérdida de calidad, como en publicaciones científicas o informes.\n\n# Guardar el gráfico en formato PDF\nggsave(\"grafico.pdf\", width = 8, height = 6)\n\nDiferencias con PNG: No es necesario especificar la resolución (dpi), ya que el formato PDF es vectorial y no depende de la resolución.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Exportación de resultados</span>"
    ]
  },
  {
    "objectID": "10_exportacion.html#guardar-tablas-en-csv-y-excel",
    "href": "10_exportacion.html#guardar-tablas-en-csv-y-excel",
    "title": "13  Exportación de resultados",
    "section": "13.3 Guardar Tablas en CSV y Excel",
    "text": "13.3 Guardar Tablas en CSV y Excel\nLa exportación de tablas es esencial para compartir datos o realizar análisis adicionales en otras herramientas. A continuación, se detalla cómo guardar tablas en formatos CSV y Excel.\n\n13.3.1 Crear un data frame de ejemplo\nSe puede utilizar un data frame de ejemplo para ilustrar el proceso:\n\n# Crear un data frame de ejemplo\nejemplo &lt;- data.frame(\n  Nombre = c(\"Ana\", \"Luis\", \"María\"),\n  Edad = c(25, 30, 22),\n  Ciudad = c(\"Madrid\", \"Barcelona\", \"Valencia\")\n)\n\n\n\n13.3.2 Guardar la tabla en formato CSV\nUtilizando la función write.csv(), se puede exportar el data frame:\n\n# Guardar la tabla en formato CSV\nwrite.csv(ejemplo, \"ejemplo.csv\", row.names = FALSE)\n\nParámetros importantes:\nfile: Nombre del archivo de salida (en este caso, \"tabla.csv\").\nrow.names: Si se establece en FALSE, no se incluirán los índices de las filas como una columna adicional.\n\n\n13.3.3 Guardar en Formato Excel\nPara exportar datos a Excel, se utiliza el paquete writexl, por lo que primero hay que instalar y cargar el paquete:\n\n# Paquete para la exportación de datos a Excel\nif (!require(\"writexl\")) install.packages(\"writexl\")\n\nDespues de haber cargado el paquete utilizando la función write_xlsx(), se puede exportar el data frame:\n\n# Guardar la tabla en formato Excel\nwrite_xlsx(ejemplo, \"ejemplo.xlsx\")\n\nParámetros importantes:\n\nobjeto: Nombre del dataframe o lista que se quiere exportar en formato Excel.\npath: Nombre del archivo de salida (en este caso, \"ejemplo.xlsx\").\n\nResultado: El archivo ejemplo.xlsx se guardará en el directorio de trabajo actual, listo para ser abierto en Microsoft Excel o software similar.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Exportación de resultados</span>"
    ]
  },
  {
    "objectID": "10_exportacion.html#comparación-de-formatos",
    "href": "10_exportacion.html#comparación-de-formatos",
    "title": "13  Exportación de resultados",
    "section": "13.4 Comparación de Formatos",
    "text": "13.4 Comparación de Formatos\n\n\n\n\n\n\n\n\n\nFormato\nUso Principal\nVentajas\nDesventajas\n\n\n\n\nPNG\nPresentaciones y documentos digitales\nAlta calidad, ampliamente compatible\nNo escalable sin pérdida de calidad\n\n\nPDF\nPublicaciones científicas e informes\nEscalable, ideal para impresión\nMenos compatible con editores básicos\n\n\nCSV\nAnálisis de datos en herramientas simples\nLigero, compatible con múltiples plataformas\nNo admite formatos complejos\n\n\nExcel\nCompartir datos estructurados\nCompatible con herramientas avanzadas\nRequiere software específico",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Exportación de resultados</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "19  Referencias",
    "section": "",
    "text": "Allaire, J. J., Xie, Y., & McPherson, J. (2022). R Markdown: The Definitive Guide. Chapman & Hall/CRC. https://www.taylorfrancis.com/books/mono/10.1201/9781138359444/markdown-yihui-xie-allaire-garrett-grolemund\nBaker, M. (2016). 1,500 scientists lift the lid on reproducibility. Nature, 533(7604), 452–454. https://doi.org/10.1038/533452a\nBelsley, D. A., Kuh, E., & Welsch, R. E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. Wiley. (No hay enlace disponible)\nCohen, J., Cohen, P., West, S. G., & Aiken, L. S. (2003). Applied Multiple Regression/Correlation Analysis for the Behavioral Sciences (3rd ed.). Lawrence Erlbaum Associates. (No hay enlace disponible)\nDraper, N. R., & Smith, H. (1998). Applied Regression Analysis (3rd ed.). Wiley. (No hay enlace disponible)\nField, A. (2013). Discovering Statistics Using IBM SPSS Statistics (4th ed.). SAGE Publications. (No hay enlace disponible)\nGentleman, R., & Temple Lang, D. (2007). Statistical analyses and reproducible research. Journal of Computational and Graphical Statistics, 16(1), 1–23. https://doi.org/10.1198/106186007X178663\nHmelo-Silver, C. E., Duncan, R. G., & Chinn, C. A. (2007). Scaffolding and achievement in problem-based and inquiry learning: A response to Kirschner, Sweller, and Clark (2006). Educational Psychologist, 42(2), 99–107. https://doi.org/10.1080/00461520701263368\nIhaka, R., & Gentleman, R. (1996). R: A Language for Data Analysis and Graphics. Journal of Computational and Graphical Statistics, 5(3), 299–314. (No hay enlace disponible)\nKolb, D. A. (1984). Experiential learning: Experience as the source of learning and development. Prentice Hall. (No hay enlace disponible)\nKutner, M. H., Nachtsheim, C. J., Neter, J., & Li, W. (2005). Applied Linear Statistical Models (5th ed.). McGraw-Hill. (No hay enlace disponible)\nLópez, E., & González, B. (2016). Diseño y análisis de experimentos. Internet Archive. https://archive.org/details/DiseoYAnlisisDeExperimentos2016\nMontgomery, D. C., Peck, E. A., & Vining, G. G. (2012). Introduction to Linear Regression Analysis (5th ed.). Wiley. (No hay enlace disponible)\nNational Academies of Sciences, Engineering, and Medicine. (2019). Reproducibility and replicability in science. National Academies Press. https://doi.org/10.17226/25303\nR Core Team. (2023). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.Rproject.org\nRosales Castillo, JM. 2005. Micropropagación de Calahuala Phlebodium psedoaureum (Cav.) Lellinger con tres tipos de explantes en diferentes medios de cultivo in vitro. Tesis Ing. Agr. Guatemala, Universidad de San Carlos de Guatemala, Facultad de Agronomía. 51 p. \nTabachnick, B. G., & Fidell, L. S. (2013). Using Multivariate Statistics (6th ed.). Pearson. (No hay enlace disponible)\nThe Turing Way Community. (2023). The Turing Way: A handbook for reproducible, ethical and collaborative research. https://the-turing-way.netlify.app\nWilkinson, M. D. et al. (2016). The FAIR Guiding Principles for scientific data management and stewardship. Scientific Data, 3(1), 160018. https://doi.org/10.1038/sdata.2016.18",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Referencias</span>"
    ]
  },
  {
    "objectID": "references.html#material-de-apoyo",
    "href": "references.html#material-de-apoyo",
    "title": "14  Material de apoyo y referencias",
    "section": "",
    "text": "Tutorial en YouTube “Cómo instalar R y RStudio en menos de 2 minutos - 2024”. Elaborado por Herbert Lizama.\nR para ciencia de datos por Handley Wickham & Garrett Grolemund",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Material de apoyo y referencias</span>"
    ]
  },
  {
    "objectID": "references.html#referencias",
    "href": "references.html#referencias",
    "title": "14  Material de apoyo y referencias",
    "section": "14.2 Referencias",
    "text": "14.2 Referencias\n\nAllaire, J. J., Xie, Y., & McPherson, J. (2022). R Markdown: The Definitive Guide. Chapman & Hall/CRC. https://www.taylorfrancis.com/books/mono/10.1201/9781138359444/markdown-yihui-xie-allaire-garrett-grolemund\nBaker, M. (2016). 1,500 scientists lift the lid on reproducibility. Nature, 533(7604), 452–454. https://doi.org/10.1038/533452a\nBelsley, D. A., Kuh, E., & Welsch, R. E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. Wiley. (No hay enlace disponible)\nCohen, J., Cohen, P., West, S. G., & Aiken, L. S. (2003). Applied Multiple Regression/Correlation Analysis for the Behavioral Sciences (3rd ed.). Lawrence Erlbaum Associates. (No hay enlace disponible)\nDraper, N. R., & Smith, H. (1998). Applied Regression Analysis (3rd ed.). Wiley. (No hay enlace disponible)\nField, A. (2013). Discovering Statistics Using IBM SPSS Statistics (4th ed.). SAGE Publications. (No hay enlace disponible)\nGentleman, R., & Temple Lang, D. (2007). Statistical analyses and reproducible research. Journal of Computational and Graphical Statistics, 16(1), 1–23. https://doi.org/10.1198/106186007X178663\nHmelo-Silver, C. E., Duncan, R. G., & Chinn, C. A. (2007). Scaffolding and achievement in problem-based and inquiry learning: A response to Kirschner, Sweller, and Clark (2006). Educational Psychologist, 42(2), 99–107. https://doi.org/10.1080/00461520701263368\nIhaka, R., & Gentleman, R. (1996). R: A Language for Data Analysis and Graphics. Journal of Computational and Graphical Statistics, 5(3), 299–314. (No hay enlace disponible)\nKolb, D. A. (1984). Experiential learning: Experience as the source of learning and development. Prentice Hall. (No hay enlace disponible)\nKutner, M. H., Nachtsheim, C. J., Neter, J., & Li, W. (2005). Applied Linear Statistical Models (5th ed.). McGraw-Hill. (No hay enlace disponible)\nLópez, E., & González, B. (2016). Diseño y análisis de experimentos. Internet Archive. https://archive.org/details/DiseoYAnlisisDeExperimentos2016\nMontgomery, D. C., Peck, E. A., & Vining, G. G. (2012). Introduction to Linear Regression Analysis (5th ed.). Wiley. (No hay enlace disponible)\nNational Academies of Sciences, Engineering, and Medicine. (2019). Reproducibility and replicability in science. National Academies Press. https://doi.org/10.17226/25303\nR Core Team. (2023). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing. https://www.Rproject.org\nRosales Castillo, JM. 2005. Micropropagación de Calahuala Phlebodium psedoaureum (Cav.) Lellinger con tres tipos de explantes en diferentes medios de cultivo in vitro. Tesis Ing. Agr. Guatemala, Universidad de San Carlos de Guatemala, Facultad de Agronomía. 51 p. \nTabachnick, B. G., & Fidell, L. S. (2013). Using Multivariate Statistics (6th ed.). Pearson. (No hay enlace disponible)\nThe Turing Way Community. (2023). The Turing Way: A handbook for reproducible, ethical and collaborative research. https://the-turing-way.netlify.app\nWilkinson, M. D. et al. (2016). The FAIR Guiding Principles for scientific data management and stewardship. Scientific Data, 3(1), 160018. https://doi.org/10.1038/sdata.2016.18",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Material de apoyo y referencias</span>"
    ]
  },
  {
    "objectID": "estadistica_descriptiva.html",
    "href": "estadistica_descriptiva.html",
    "title": "20  Estadística descriptiva usando funciones en R",
    "section": "",
    "text": "20.1 Medidas principales en estadística descriptiva\nLa estadística descriptiva es una rama esencial de la estadística que se ocupa de resumir y describir las características principales de un conjunto de datos. Su propósito es proporcionar una visión clara y comprensible de los datos, permitiendo identificar patrones, tendencias y comportamientos generales sin realizar inferencias o predicciones. Este tipo de análisis es el primer paso en cualquier estudio estadístico, ya que organiza y presenta la información de manera que sea fácil de interpretar.\nEn R, la estadística descriptiva se puede realizar de manera eficiente gracias a una amplia variedad de herramientas y funciones predefinidas, así como paquetes especializados que amplían las capacidades del análisis. Estas herramientas permiten calcular medidas clave que se agrupan en tres categorías principales: medidas de tendencia central, medidas de dispersión y medidas de forma.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Estadística descriptiva usando funciones en R</span>"
    ]
  },
  {
    "objectID": "estadistica_descriptiva.html#medidas-principales-en-estadística-descriptiva",
    "href": "estadistica_descriptiva.html#medidas-principales-en-estadística-descriptiva",
    "title": "20  Estadística descriptiva usando funciones en R",
    "section": "",
    "text": "20.1.1 Medidas de tendencia central\nLas medidas de tendencia central describen el valor típico o central de un conjunto de datos. Estas medidas son fundamentales para resumir los datos en un solo valor representativo.\nMedia aritmética: Es el promedio aritmético de los datos. Se calcula sumando todos los valores y dividiendo entre el número total de observaciones. Es sensible a valores extremos (outliers).\nFórmula:\n\n\n\n\n\nEjemplo en R:\n\ndatos &lt;- c(10, 20, 30, 40, 50)\nmedia &lt;- mean(datos)\nprint(media)  # Resultado: \n\n[1] 30\n\n\nMediana: Es el valor que divide el conjunto de datos en dos partes iguales, de modo que el 50% de los valores son menores o iguales a la mediana y el otro 50% son mayores o iguales. Es menos sensible a valores extremos que la media.\nEjemplo en R:\n\nmediana &lt;- median(datos)\nprint(mediana)  # Resultado: \n\n[1] 30\n\n\nModa: Es el valor o los valores que ocurren con mayor frecuencia en un conjunto de datos. En R base, no existe una función predefinida para calcular la moda, pero se puede implementar fácilmente.\nEjemplo de función para calcular la moda:\n\nmoda_ej &lt;- function(x) {\n  tabla &lt;- table(x)\n  moda &lt;- names(tabla[tabla == max(tabla)])\n  return(moda)\n}\ndatos_moda &lt;- c(10, 20, 20, 30, 40)\nprint(moda_ej(datos_moda))  # Resultado: \n\n[1] \"20\"\n\n\n\n\n20.1.2 Medidas de dispersión\nLas medidas de dispersión describen la variabilidad o el grado de dispersión de los datos en torno a la media. Estas medidas son esenciales para entender la distribución de los datos.\nVarianza: Mide la dispersión de los datos respecto a la media. Es el promedio de las diferencias al cuadrado entre cada valor y la media. Una varianza alta indica que los datos están muy dispersos.\nFórmula de la varianza muestral:\n\n\n\n\n\n\nvarianza &lt;- var(datos)\nprint(varianza)  # Resultado: \n\n[1] 250\n\n\nDesviación estándar: Es la raíz cuadrada de la varianza. Proporciona una medida de dispersión en las mismas unidades que los datos originales.\nFórmula:\n\n\n\n\n\nEjemplo en R:\n\ndesviacion &lt;- sd(datos)\nprint(desviacion)  # Resultado:\n\n[1] 15.81139\n\n\nRango: Es la diferencia entre el valor máximo y el valor mínimo de los datos. Es una medida simple pero útil para entender la amplitud de los datos.\nEjemplo en R:\n\nrango &lt;- max(datos)-min(datos)\nprint(rango)  # Resultado: \n\n[1] 40\n\n\nRango intercuartílico (IQR): Es la diferencia entre el tercer cuartil (Q3) y el primer cuartil (Q1). Representa la dispersión de la mitad central de los datos y es menos sensible a valores extremos.\nFórmula:\n\n\n\n\n\nEjemplo en R:\n\niqr &lt;- IQR(datos)\nprint(iqr)  # Resultado: \n\n[1] 20\n\n\n\n\n20.1.3 Medidas de forma\nLas medidas de forma describen la distribución de los datos en términos de su simetría y concentración en torno a la media.\nAsimetría (skewness): Mide el grado de simetría de la distribución de los datos. Una asimetría positiva indica que la cola derecha es más larga, mientras que una asimetría negativa indica que la cola izquierda es más larga.\nGuía gráfica para interpretar asimetría:\n\n\n\n\n\nFórmula:\n\n\n\n\n\nEjemplo en R (usando el paquete psych):\n\n# Instalación y carga del paquete psych\nif (!require(\"psych\")) install.packages(\"psych\")\n\n# Análisis de asimetria\ndatos &lt;- c(10, 20, 30, 40, 50)\nasimetria &lt;- skew(datos)\nprint(asimetria)  # Resultado: 0 (distribución simétrica)\n\n[1] 0\n\n\nCurtosis (kurtosis): Mide la concentración de los datos en torno a la media. Una curtosis alta indica una distribución con colas más pesadas (leptocúrtica), mientras que una curtosis baja indica colas más ligeras (platicúrtica).\nGuía gráfica para interpretar curtosis:\n\n\n\n\n\nFórmula:\n\n\n\n\n\nEjemplo en R (usando el paquete psych):\n\ncurtosis &lt;- kurtosi(datos)\nprint(curtosis)  # Resultado: -1.912 (distribución platicúrtica)\n\n[1] -1.912",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Estadística descriptiva usando funciones en R</span>"
    ]
  },
  {
    "objectID": "estadistica_descriptiva.html#base-de-datos-para-los-ejemplos",
    "href": "estadistica_descriptiva.html#base-de-datos-para-los-ejemplos",
    "title": "20  Estadística descriptiva usando funciones en R",
    "section": "20.2 Base de datos para los ejemplos",
    "text": "20.2 Base de datos para los ejemplos\nEn 2002, se llevó a cabo un estudio en la Universidad de San Carlos de Guatemala, en el que se recopilaron datos de 460 estudiantes de diversas facultades, generando una base de datos que incluye una amplia variedad de variables como: FACULTAD, EDAD, SEXO, EST_CIVIL, PESO_lbs, TALLA, entre otras. Esta base de datos, disponible para su descarga en formato CSV, se utilizará a lo largo de esta sección del manual para ilustrar diferentes métodos de análisis descriptivo de datos, adaptando las herramientas y conceptos desarrollados a las características de las variables incluidas. Para seguir los ejemplos prácticos, se recomienda que el usuario descargue el archivo y lo guarde en la carpeta correspondiente al proyecto en curso.\n\n20.2.1 Preparación del área de trabajo\nAntes de comenzar con el análisis, es necesario preparar el entorno de trabajo instalando y cargando los paquetes necesarios, estableciendo el directorio de trabajo y revisando la estructura de los datos.\n\n# Instalación y carga de paquetes  \n # Incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n # Exportación a Excel\nif (!require(\"writexl\")) install.packages(\"writexl\")  \n\n # Realiza analisis de estaística descriptiva completos\nif (!require(\"psych\")) install.packages(\"psych\")\n\n # Se utiliza para establecer el directorio de trabajo \nif (!require(\"rstudioapi\")) install.packages(\"rstudioapi\")\n\n\n\n20.2.2 Establecer directorio de trabajo\nEs importante asegurarse de que el archivo de datos esté en el directorio de trabajo correcto. Esto se puede hacer con el siguiente código una vez ya se ha guardado el script:\n\n# Establecer y verificar directorio de trabajo\nsetwd(dirname(rstudioapi::getActiveDocumentContext()$path))\ngetwd()\n\n\n\n20.2.3 Importar la base de datos\nUna vez establecido el directorio de trabajo, se puede importar la base de datos en formato CSV:\n\n# Importar la base de datos\nestudiantes&lt;- read_csv(\"datos_estudiantes.csv\")\n\n\n\n20.2.4 Revisar de la estructura de los datos\nEs fundamental revisar la estructura de los datos para entender el tipo de variables y su formato:\n\n# Revisar la estructura de los datos\nsapply(estudiantes, class)\n\n# Convertir todos los nombres de las columnas a minúsculas\nnames(estudiantes)&lt;- tolower(names(estudiantes))\n\n# Tener todas las variables en minúsculas facilita su manipulación\n\n# Revisar los valores de las variables categoricas \ncategoricas&lt;-list(facultad = c(unique(estudiantes$facultad)),\n           sexo = c(unique(estudiantes$sexo)), \n           est_civil = c(unique(estudiantes$est_civil)),\n           trabaja = c(unique(estudiantes$trabaja)),\n           jornada = c(unique(estudiantes$jornada)),\n           fuma = c(unique(estudiantes$fuma)),\n           alcohol = c(unique(estudiantes$alcohol)))\n\n\n\n20.2.5 Limpieza de la base de datos\nAntes de realizar el análisis, es necesario limpiar los datos para corregir valores inconsistentes y asegurarse de que las variables estén en el formato adecuado:\n\n# Corregir los valores incorrectos de la variable \"fuma\"\nestudiantes$fuma &lt;- ifelse(tolower(estudiantes$fuma) == \"sí\",\n                           1, estudiantes$fuma)\nunique(estudiantes$fuma)\n\n[1] \"2\" \"1\"\n\n# Establecer como varibales tipo factor a las variables categoricas\nestudiantes &lt;- estudiantes %&gt;%\n  mutate(across(\n    c(facultad, sexo, est_civil, trabaja, jornada, fuma, alcohol), \n    as.factor))",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Estadística descriptiva usando funciones en R</span>"
    ]
  },
  {
    "objectID": "estadistica_descriptiva.html#funciones-por-defecto-en-r-para-estadística-descriptiva",
    "href": "estadistica_descriptiva.html#funciones-por-defecto-en-r-para-estadística-descriptiva",
    "title": "20  Estadística descriptiva usando funciones en R",
    "section": "20.3 Funciones por defecto en R para estadística descriptiva",
    "text": "20.3 Funciones por defecto en R para estadística descriptiva\nR base proporciona varias funciones útiles para realizar análisis descriptivos básicos. A continuación, se presentan ejemplos utilizando la base de datos de estudiantes.\n\n20.3.1 Medidas de tendencia central\nLas medidas de tendencia central describen el valor típico o central de un conjunto de datos.\nMedia: Promedio de los valores.\nMediana: Valor que divide los datos en dos partes iguales.\nModa: Valor más frecuente (no existe una función por defecto en R para calcular la moda).\n\n# Calcular medidas de tendencia central para la variable \"edad\"\nmedia_edad &lt;- mean(estudiantes$edad, na.rm = TRUE)\nmediana_edad &lt;- median(estudiantes$edad, na.rm = TRUE)\n\n# Resultados\nprint(paste(\"Media:\", media_edad))\n\n[1] \"Media: 24.0195652173913\"\n\nprint(paste(\"Mediana:\", mediana_edad))\n\n[1] \"Mediana: 22\"\n\n\n\n\n20.3.2 Medidas de dispersión\nLas medidas de dispersión describen la variabilidad de los datos.\nVarianza: Dispersión respecto a la media.\nDesviación estándar: Raíz cuadrada de la varianza.\nRango: Diferencia entre el valor máximo y mínimo.\nRango intercuartílico (IQR): Diferencia entre el tercer y primer cuartil.\n\n# Calcular medidas de dispersión para la variable \"peso_lbs\"\nvarianza_peso &lt;- var(estudiantes$peso_lbs, na.rm = TRUE)\ndesviacion_peso &lt;- sd(estudiantes$peso_lbs, na.rm = TRUE)\nrango_peso &lt;- max(estudiantes$peso_lbs)-min(estudiantes$peso_lbs)\niqr_peso &lt;- IQR(estudiantes$peso_lbs, na.rm = TRUE)\n\n# Resultados\nprint(paste(\"Varianza:\", varianza_peso))\n\n[1] \"Varianza: 872.415330870512\"\n\nprint(paste(\"Desviación estándar:\", desviacion_peso))\n\n[1] \"Desviación estándar: 29.5366777222915\"\n\nprint(paste(\"Rango:\", paste(rango_peso)))\n\n[1] \"Rango: 170\"\n\nprint(paste(\"IQR:\", iqr_peso))\n\n[1] \"IQR: 40\"\n\n\n\n\n20.3.3 Medidas de forma\nLas medidas de forma describen la distribución de los datos en términos de simetría y concentración.\nAsimetría: Grado de simetría de la distribución.\nCurtosis: Concentración de los datos en torno a la media.\nLa asimetría y curtosis no se pueden calcular con la funciones base de R para ello se debe emplear el paquete psych, con este las medidas de forma se calculan fácilmente:\n\n# Calcular asimetría y curtosis para la variable \"talla\"\nasimetria_talla &lt;- skew(estudiantes$talla, na.rm = TRUE)\ncurtosis_talla &lt;- kurtosi(estudiantes$talla, na.rm = TRUE)\n\n# Resultados\nprint(paste(\"Asimetría:\", asimetria_talla))\n\n[1] \"Asimetría: 0.0362232638780007\"\n\nprint(paste(\"Curtosis:\", curtosis_talla))\n\n[1] \"Curtosis: -0.177190677008652\"\n\n\n\n\n20.3.4 Resumen general con summary()\nLa función summary() proporciona un resumen estadístico básico para variables numéricas y categóricas:\n\n# Resumen general de la variable talla\nresumen_general &lt;- summary(estudiantes$talla)\nprint(resumen_general)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  1.280   1.570   1.630   1.639   1.700   1.900",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Estadística descriptiva usando funciones en R</span>"
    ]
  },
  {
    "objectID": "estadistica_descriptiva.html#paquetes-especializados-para-estadística-descriptiva-el-paquete-psych",
    "href": "estadistica_descriptiva.html#paquetes-especializados-para-estadística-descriptiva-el-paquete-psych",
    "title": "20  Estadística descriptiva usando funciones en R",
    "section": "20.4 Paquetes especializados para estadística descriptiva (el paquete psych)",
    "text": "20.4 Paquetes especializados para estadística descriptiva (el paquete psych)\nEl paquete psych es una herramienta poderosa y versátil para realizar análisis estadísticos descriptivos avanzados en R. Este paquete es especialmente útil cuando se trabaja con variables categóricas y numéricas simultáneamente, ya que permite calcular estadísticas detalladas, realizar análisis por grupos y obtener medidas de forma como asimetría y curtosis. Además, incluye opciones para calcular errores estándar e intervalos de confianza, lo que lo convierte en una excelente opción para análisis más completos.\n\n20.4.1 Instalación y carga del paquete\n\n# Instalación y carga del paquete\nif (!require(\"psych\")) install.packages(\"psych\")\n\n\n\n20.4.2 Análisis descriptivo general\nA continuación, se utilizará la base de datos de estudiantes para realizar un análisis descriptivo detallado. Este análisis incluirá medidas de tendencia central, dispersión y forma.\nLa función describe() del paquete psych permite calcular estadísticas descriptivas detalladas para variables numéricas. Estas estadísticas incluyen: Media, Desviación estándar, Mediana, Rango, Asimetría, Curtosis, Errores estándar.\n\n# Análisis descriptivo general para variables numéricas\nresultado_general &lt;- describe(estudiantes[, c(\"edad\", \"peso_lbs\", \"talla\")])\n\n# Mostrar resultados\nprint(resultado_general)\n\n         vars   n   mean    sd median trimmed   mad   min   max  range skew\nedad        1 460  24.02  5.74  22.00   22.99  2.97 17.00  55.0  38.00 1.94\npeso_lbs    2 460 139.44 29.54 134.00  137.46 29.65 79.00 249.0 170.00 0.68\ntalla       3 460   1.64  0.09   1.63    1.64  0.10  1.28   1.9   0.62 0.04\n         kurtosis   se\nedad         4.39 0.27\npeso_lbs     0.42 1.38\ntalla       -0.18 0.00\n\n\nSalida esperada: El resultado incluye un resumen detallado de cada variable numérica, con estadísticas como la media, desviación estándar, asimetría y curtosis.\n\n\n20.4.3 Análisis descriptivo categorizado\nLa función describeBy() permite realizar un análisis descriptivo agrupado por una o más variables categóricas. Esto es útil para comparar estadísticas entre diferentes grupos.\n\n# Análisis descriptivo agrupado por sexo y trabaja\nresultado_agrupado &lt;- describeBy(\n  estudiantes[, c(\"edad\", \"peso_lbs\", \"talla\")], \n  group = list(estudiantes$sexo, estudiantes$trabaja)\n)\n\n# Mostrar resultados\nprint(resultado_agrupado)\n\n\n Descriptive statistics by group \n: F\n: 1\n         vars  n   mean    sd median trimmed   mad   min    max  range  skew\nedad        1 76  26.04  5.69  25.00   25.37  5.93 18.00  42.00  24.00  0.91\npeso_lbs    2 76 126.67 25.32 122.50  124.05 20.76 79.00 199.00 120.00  0.97\ntalla       3 76   1.57  0.08   1.57    1.57  0.07  1.28   1.75   0.47 -0.42\n         kurtosis   se\nedad         0.14 0.65\npeso_lbs     0.86 2.90\ntalla        1.73 0.01\n------------------------------------------------------------ \n: M\n: 1\n         vars   n   mean    sd median trimmed   mad    min    max  range  skew\nedad        1 105  27.58  7.49   25.0   26.59  5.93  18.00  55.00  37.00  1.26\npeso_lbs    2 105 156.31 26.94  152.0  154.75 25.20 102.00 238.00 136.00  0.61\ntalla       3 105   1.70  0.07    1.7    1.70  0.07   1.49   1.85   0.36 -0.09\n         kurtosis   se\nedad         1.34 0.73\npeso_lbs     0.41 2.63\ntalla       -0.15 0.01\n------------------------------------------------------------ \n: F\n: 2\n         vars   n   mean    sd median trimmed   mad  min    max  range skew\nedad        1 154  22.57  4.51  21.00   21.77  2.97 17.0  44.00  27.00 2.53\npeso_lbs    2 154 125.66 24.56 120.00  123.27 17.79 84.0 227.00 143.00 1.07\ntalla       3 154   1.59  0.07   1.58    1.58  0.06  1.4   1.78   0.38 0.44\n         kurtosis   se\nedad         7.79 0.36\npeso_lbs     1.37 1.98\ntalla       -0.07 0.01\n------------------------------------------------------------ \n: M\n: 2\n         vars   n   mean    sd median trimmed   mad   min   max  range skew\nedad        1 125  21.58  2.87   21.0   21.24  1.48 17.00  34.0  17.00 1.66\npeso_lbs    2 125 149.99 28.27  147.0  148.49 26.69 88.00 249.0 161.00 0.64\ntalla       3 125   1.69  0.08    1.7    1.69  0.07  1.52   1.9   0.38 0.10\n         kurtosis   se\nedad         4.34 0.26\npeso_lbs     0.92 2.53\ntalla       -0.05 0.01\n\n\nNota importante: Cuando se utiliza describeBy(), el paquete psych genera una tabla separada para cada combinación de las variables categóricas. Esto puede ser útil para análisis simples, pero puede volverse limitante en casos donde se necesite consolidar los resultados en un solo dataframe o realizar análisis más complejos.\n\n\n20.4.4 Exportación de resultados\nLos resultados del análisis descriptivo pueden exportarse fácilmente a un archivo Excel para su revisión o presentación:\n\n# Exportar resultados agrupados a Excel\nwrite_xlsx(resultado_agrupado, \"analisis_descriptivo_psych.xlsx\")\n\n\n\n20.4.5 Ventajas del paquete psych\nEl paquete psych ofrece varias ventajas para el análisis descriptivo:\n\nEstadísticas más detalladas: Incluye medidas avanzadas como asimetría, curtosis, errores estándar e intervalos de confianza.\nAnálisis por grupos: Permite calcular estadísticas descriptivas para diferentes combinaciones de variables categóricas.\nFlexibilidad: Facilita la categorización de variables numéricas en rangos personalizados.\nExportación de resultados: Los resultados pueden exportarse fácilmente a formatos como Excel para su análisis posterior.\n\n\n\n20.4.6 Limitaciones del paquete psych\nAunque el paquete psych es muy útil, presenta algunas limitaciones:\n\nResultados separados por combinación de categorías: La función describeBy() genera una tabla separada para cada combinación de las variables categóricas, lo que puede dificultar la consolidación de los resultados en un solo archivo o dataframe.\nFalta de personalización: No permite agregar estadísticas personalizadas, como percentiles específicos o medidas adicionales que no estén incluidas en las funciones predefinidas.\nManejo de valores faltantes: Aunque maneja valores faltantes de manera básica, no ofrece opciones avanzadas para imputación o análisis detallado de datos incompletos.\nExportación limitada: Los resultados no están listos para exportarse directamente en un formato tabular consolidado, lo que requiere pasos adicionales para su preparación.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Estadística descriptiva usando funciones en R</span>"
    ]
  },
  {
    "objectID": "estadistica_descriptiva.html#función-personalizada-para-análisis-descriptivo-completo",
    "href": "estadistica_descriptiva.html#función-personalizada-para-análisis-descriptivo-completo",
    "title": "20  Estadística descriptiva usando funciones en R",
    "section": "20.5 Función personalizada para análisis descriptivo completo",
    "text": "20.5 Función personalizada para análisis descriptivo completo\nPara superar las limitaciones del paquete psych, se puede utilizar una función personalizada que ofrezca mayor flexibilidad y personalización. A continuación, se presenta una solución que incluye funciones auxiliares para calcular medidas avanzadas como la moda, asimetría y curtosis.\n\n20.5.1 Establecer funciones auxiliares\n\n20.5.1.1 Moda\n\n# Función de la moda\nmoda &lt;- function(x) {\n  # Eliminar valores NA\n  x &lt;- na.omit(x)\n  \n  # Verificar si el vector está vacío\n  if (length(x) == 0) return(NA_character_)\n  \n  # Calcular la frecuencia de cada valor\n  tabla &lt;- table(x)\n  \n  # Identificar el/los valores con mayor frecuencia\n  max_frecuencia &lt;- max(tabla)\n  modas &lt;- names(tabla[tabla == max_frecuencia])\n  \n  # Verificar si todos los valores son únicos (sin moda)\n  if (max_frecuencia == 1) return(NA_character_)\n  \n  # Retornar la moda como un string separado por comas\n  return(paste(modas, collapse = \", \"))\n}\n\n\n\n20.5.1.2 Asimetría\n\n# Función Asimentría\ncalcular_asimetria &lt;- function(x) {\n  # Eliminar valores NA\n  x &lt;- na.omit(x)\n  \n  # Verificar que haya suficientes datos\n  if (length(x) &lt; 3) return(NA_real_)\n  \n  # Calcular media y desviación estándar\n  m &lt;- mean(x)\n  s &lt;- sd(x)\n  \n  # Manejar el caso de desviación estándar cero\n  if (s == 0) return(0)\n  \n  # Calcular asimetría\n  asimetria &lt;- sum((x - m)^3) / (length(x) * s^3)\n  return(asimetria)\n}\n\n\n\n20.5.1.3 Curtosis\n\n# Función Curtosis \ncalcular_curtosis &lt;- function(x) {\n  # Eliminar valores NA\n  x &lt;- na.omit(x)\n  \n  # Verificar que haya suficientes datos\n  if (length(x) &lt; 4) return(NA_real_)\n  \n  # Calcular media y desviación estándar\n  m &lt;- mean(x)\n  s &lt;- sd(x)\n  \n  # Manejar el caso de desviación estándar cero\n  if (s == 0) return(0)\n  \n  # Calcular curtosis\n  curtosis &lt;- sum((x - m)^4) / (length(x) * s^4) - 3\n  return(curtosis)\n}\n\n\n\n\n20.5.2 Función principal: análisis por categorías\nLa función principal realiza el análisis descriptivo agrupando los datos según las variables categóricas especificadas. Calcula estadísticas clave como la media, mediana, moda, desviación estándar, varianza, rango, cuartiles, asimetría y curtosis.\n\n# Función Análisis por Categoría\nanalisis_por_categoria &lt;- function(datos, \n                                   columna_numerica,\n                                   columnas_categoricas) {\n  datos %&gt;%\n    group_by(across(all_of(columnas_categoricas))) %&gt;%\n    summarise(\n      Variable = columna_numerica,\n      N_validos = sum(!is.na(.data[[columna_numerica]])),\n      N_missing = sum(is.na(.data[[columna_numerica]])),\n      Media = mean(.data[[columna_numerica]], na.rm = TRUE),\n      Mediana = median(.data[[columna_numerica]], na.rm = TRUE),\n      Moda = moda(.data[[columna_numerica]]),\n      Desviacion_estandar = sd(.data[[columna_numerica]], na.rm = TRUE),\n      Varianza = var(.data[[columna_numerica]], na.rm = TRUE),\n      Rango_min = min(.data[[columna_numerica]], na.rm = TRUE),\n      Rango_max = max(.data[[columna_numerica]], na.rm = TRUE),\n      Rango = Rango_max - Rango_min,\n      IQR = IQR(.data[[columna_numerica]], na.rm = TRUE),\n      Q1 = quantile(.data[[columna_numerica]], probs = 0.25, na.rm = TRUE),\n      Q2 = quantile(.data[[columna_numerica]], probs = 0.50, na.rm = TRUE),\n      Q3 = quantile(.data[[columna_numerica]], probs = 0.75, na.rm = TRUE),\n      Asimetria = calcular_asimetria(.data[[columna_numerica]]),\n      Curtosis = calcular_curtosis(.data[[columna_numerica]]),\n      .groups = 'drop'\n    )\n}\n\n\n\n20.5.3 Función para análisis de múltiples variables numéricas\nPara analizar varias columnas numéricas simultáneamente, se puede usar la siguiente función, que aplica analisis_por_categoria a cada columna numérica especificada:\n\n# Función para anlisar multiples variables numericas simultaneamente \nanalisis_multiple &lt;- function(datos, \n                              columnas_numericas,\n                              columnas_categoricas) {\n  resultados &lt;- list()\n  for (col in columnas_numericas) {\n    resultados[[col]] &lt;- analisis_por_categoria(\n      datos = datos,\n      columna_numerica = col,\n      columnas_categoricas = columnas_categoricas\n    )\n  }\n  bind_rows(resultados)  # Combina todos los resultados en un dataframe\n}\n\n\n\n20.5.4 Ejemplo de uso\nPara ilustrar el uso de la función personalizada, se realizará un análisis descriptivo completo utilizando la base de datos de estudiantes de la Universidad de San Carlos de Guatemala. Este ejemplo mostrará cómo analizar múltiples variables numéricas categorizadas por diferentes variables cualitativas.\n\n20.5.4.1 Preparación del análisis\nAntes de ejecutar el análisis, es necesario definir las columnas numéricas y categóricas que se incluirán en el estudio. Las columnas numéricas representan las variables cuantitativas que se analizarán, mientras que las columnas categóricas se utilizarán para agrupar los datos.\n\n# Definir las columnas numéricas y categóricas\n# Variables cuantitativas\ncolumnas_numericas &lt;- c(\"talla\", \"peso_lbs\", \"edad\")  \n\n# Variables cualitativas\ncolumnas_categoricas &lt;- c(\"sexo\", \"trabaja\")         \n\nA continuación, se ejecuta la función analisis_multiple, que aplica el análisis descriptivo a cada variable numérica, agrupando los resultados según las categorías especificadas.\n\n# Ejecutar el análisis descriptivo completo\nresultados_finales &lt;- analisis_multiple(\n  datos = estudiantes,\n  columnas_numericas = columnas_numericas,\n  columnas_categoricas = columnas_categoricas\n)\n\n\n\n20.5.4.2 Visualización de resultados\nLos resultados del análisis se almacenan en un objeto llamado resultados_finales, que contiene un resumen estadístico detallado para cada combinación de las variables categóricas. Este resumen incluye medidas como la media, mediana, moda, desviación estándar, varianza, rango, asimetría y curtosis, entre otras.\nPara visualizar los resultados directamente en la consola, se utiliza la función print(). El resultado es una tabla organizada que muestra las estadísticas descriptivas para cada combinación de las categorías sexo y trabaja.\n\n# Mostrar resultados\nprint(resultados_finales)\n\n# A tibble: 12 × 19\n   sexo  trabaja Variable N_validos N_missing  Media Mediana Moda \n   &lt;fct&gt; &lt;fct&gt;   &lt;chr&gt;        &lt;int&gt;     &lt;int&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;\n 1 F     1       talla           76         0   1.57    1.57 1.57 \n 2 F     2       talla          154         0   1.59    1.58 1.6  \n 3 M     1       talla          105         0   1.70    1.7  1.7  \n 4 M     2       talla          125         0   1.69    1.7  1.7  \n 5 F     1       peso_lbs        76         0 127.    122.   130  \n 6 F     2       peso_lbs       154         0 126.    120    114  \n 7 M     1       peso_lbs       105         0 156.    152    150  \n 8 M     2       peso_lbs       125         0 150.    147    150  \n 9 F     1       edad            76         0  26.0    25    21   \n10 F     2       edad           154         0  22.6    21    21   \n11 M     1       edad           105         0  27.6    25    22   \n12 M     2       edad           125         0  21.6    21    21   \n# ℹ 11 more variables: Desviacion_estandar &lt;dbl&gt;, Varianza &lt;dbl&gt;,\n#   Rango_min &lt;dbl&gt;, Rango_max &lt;dbl&gt;, Rango &lt;dbl&gt;, IQR &lt;dbl&gt;, Q1 &lt;dbl&gt;,\n#   Q2 &lt;dbl&gt;, Q3 &lt;dbl&gt;, Asimetria &lt;dbl&gt;, Curtosis &lt;dbl&gt;\n\n\nAdemás de visualizar los resultados en la consola, es posible exportarlos a un archivo Excel para facilitar su revisión o presentación:\n\n# Exportar resultados a Excel para mejor visualización\nwrite_xlsx(resultados_finales, \"analisis_descriptivo_estudiantes.xlsx\")\n\nEste ejemplo demuestra cómo utilizar la función personalizada para realizar un análisis descriptivo completo y categorizado. La tabla resultante proporciona una visión detallada de las características de las variables numéricas, agrupadas por categorías cualitativas. Además, la posibilidad de exportar los resultados a Excel permite compartir y analizar los datos de manera más eficiente.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Estadística descriptiva usando funciones en R</span>"
    ]
  },
  {
    "objectID": "estadistica_descriptiva.html#resumen-comparativo-funciones-base-de-r-paquete-psych-y-función-personalizada",
    "href": "estadistica_descriptiva.html#resumen-comparativo-funciones-base-de-r-paquete-psych-y-función-personalizada",
    "title": "20  Estadística descriptiva usando funciones en R",
    "section": "20.6 Resumen Comparativo: Funciones Base de R, Paquete psych y Función Personalizada",
    "text": "20.6 Resumen Comparativo: Funciones Base de R, Paquete psych y Función Personalizada\nA continuación, se presenta una comparación entre el paquete psych y la función personalizada para realizar análisis descriptivos, destacando las fortalezas y limitaciones de cada enfoque. Esta comparación permite identificar cuál es la mejor opción según las necesidades específicas del análisis.\n\n\n\n\n\n\n\n\n\nCaracterística\nFunciones Base de R\nPaquete psych\nFunción Personalizada\n\n\n\n\nEstadísticas avanzadas\nCalcula medidas básicas como media, mediana, desviación estándar, varianza y rango.\nIncluye medidas como asimetría y curtosis.\nIncluye asimetría, curtosis, moda y más estadísticas avanzadas.\n\n\nAnálisis por grupos\nRequiere pasos adicionales para agrupar y calcular estadísticas por categorías.\nGenera tablas separadas para cada combinación de categorías, lo que puede dificultar la consolidación.\nConsolida todos los resultados en un único dataframe, facilitando su manejo y análisis.\n\n\nFlexibilidad\nLimitada a las funciones predefinidas, sin opciones para personalización avanzada.\nLimitada a las funciones predefinidas del paquete.\nTotalmente personalizable, permitiendo agregar o modificar estadísticas según las necesidades.\n\n\nExportación\nRequiere pasos adicionales para preparar los resultados antes de exportarlos.\nRequiere pasos adicionales para preparar los resultados antes de exportarlos.\nLos resultados están listos para exportarse directamente en un formato tabular.\n\n\nFacilidad de uso\nMuy fácil de usar para cálculos básicos, pero limitada en análisis avanzados.\nFácil de usar para análisis avanzados estándar.\nRequiere más configuración inicial, pero ofrece mayor control y personalización.\n\n\nManejo de valores faltantes\nManejo básico con argumentos como na.rm = TRUE.\nManejo básico de valores faltantes.\nPermite un manejo avanzado y personalizado de valores faltantes.\n\n\n\nLas funciones base de R son ideales para cálculos rápidos y sencillos, como la media (mean()), mediana (median()), desviación estándar (sd()), varianza (var()), rango (range()), y el resumen general (summary()). Estas funciones son fáciles de usar y están disponibles de forma predeterminada, lo que las convierte en una excelente opción para análisis básicos. Sin embargo, su alcance es limitado cuando se requiere un análisis más detallado o agrupado, ya que no incluyen medidas avanzadas como asimetría o curtosis, ni permiten un análisis categorizado sin pasos adicionales.\nEl paquete psych es una herramienta poderosa y fácil de usar para realizar análisis descriptivos avanzados, especialmente cuando se busca rapidez y simplicidad en el cálculo de estadísticas estándar. Ofrece medidas avanzadas como asimetría y curtosis, y permite realizar análisis agrupados con la función describeBy(). Sin embargo, su enfoque en generar tablas separadas para cada combinación de categorías puede ser una limitación en proyectos que requieren consolidar resultados o realizar análisis más complejos. Además, la personalización de las estadísticas calculadas es limitada, ya que depende de las funciones predefinidas del paquete.\nPor otro lado, la función personalizada destaca por su flexibilidad y capacidad de adaptación. Permite incluir estadísticas adicionales, como la moda, y consolidar resultados en un único dataframe, lo que facilita su manejo y exportación en un formato listo para su uso. Además, ofrece un control total sobre el análisis, permitiendo adaptarlo a necesidades específicas, como el manejo avanzado de valores faltantes o la categorización de variables numéricas. Esto la convierte en una opción ideal para proyectos que demandan un mayor nivel de personalización y control.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Estadística descriptiva usando funciones en R</span>"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "Licencia",
    "section": "",
    "text": "Creative Commons Legal Code\nCC0 1.0 Universal\nCREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE\nLEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN\nATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS\nINFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES\nREGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS\nPROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM\nTHE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED\nHEREUNDER.\nStatement of Purpose\nThe laws of most jurisdictions throughout the world automatically confer exclusive Copyright and Related Rights (defined below) upon the creator and subsequent owner(s) (each and all, an “owner”) of an original work of authorship and/or a database (each, a “Work”).\nCertain owners wish to permanently relinquish those rights to a Work for the purpose of contributing to a commons of creative, cultural and scientific works (“Commons”) that the public can reliably and without fear of later claims of infringement build upon, modify, incorporate in other works, reuse and redistribute as freely as possible in any form whatsoever and for any purposes, including without limitation commercial purposes. These owners may contribute to the Commons to promote the ideal of a free culture and the further production of creative, cultural and scientific works, or to gain reputation or greater distribution for their Work in part through the use and efforts of others.\nFor these and/or other purposes and motivations, and without any expectation of additional consideration or compensation, the person associating CC0 with a Work (the “Affirmer”), to the extent that he or she is an owner of Copyright and Related Rights in the Work, voluntarily elects to apply CC0 to the Work and publicly distribute the Work under its terms, with knowledge of his or her Copyright and Related Rights in the Work and the meaning and intended legal effect of CC0 on those rights.\n\nCopyright and Related Rights. A Work made available under CC0 may be protected by copyright and related or neighboring rights (“Copyright and Related Rights”). Copyright and Related Rights include, but are not limited to, the following:\n\n\n\nthe right to reproduce, adapt, distribute, perform, display, communicate, and translate a Work;\nmoral rights retained by the original author(s) and/or performer(s);\npublicity and privacy rights pertaining to a person’s image or likeness depicted in a Work;\nrights protecting against unfair competition in regards to a Work, subject to the limitations in paragraph 4(a), below;\nrights protecting the extraction, dissemination, use and reuse of data in a Work;\ndatabase rights (such as those arising under Directive 96/9/EC of the European Parliament and of the Council of 11 March 1996 on the legal protection of databases, and under any national implementation thereof, including any amended or successor version of such directive); and\nother similar, equivalent or corresponding rights throughout the world based on applicable law or treaty, and any national implementations thereof.\n\n\n\nWaiver. To the greatest extent permitted by, but not in contravention of, applicable law, Affirmer hereby overtly, fully, permanently, irrevocably and unconditionally waives, abandons, and surrenders all of Affirmer’s Copyright and Related Rights and associated claims and causes of action, whether now known or unknown (including existing as well as future claims and causes of action), in the Work (i) in all territories worldwide, (ii) for the maximum duration provided by applicable law or treaty (including future time extensions), (iii) in any current or future medium and for any number of copies, and (iv) for any purpose whatsoever, including without limitation commercial, advertising or promotional purposes (the “Waiver”). Affirmer makes the Waiver for the benefit of each member of the public at large and to the detriment of Affirmer’s heirs and successors, fully intending that such Waiver shall not be subject to revocation, rescission, cancellation, termination, or any other legal or equitable action to disrupt the quiet enjoyment of the Work by the public as contemplated by Affirmer’s express Statement of Purpose.\nPublic License Fallback. Should any part of the Waiver for any reason be judged legally invalid or ineffective under applicable law, then the Waiver shall be preserved to the maximum extent permitted taking into account Affirmer’s express Statement of Purpose. In addition, to the extent the Waiver is so judged Affirmer hereby grants to each affected person a royalty-free, non transferable, non sublicensable, non exclusive, irrevocable and unconditional license to exercise Affirmer’s Copyright and Related Rights in the Work (i) in all territories worldwide, (ii) for the maximum duration provided by applicable law or treaty (including future time extensions), (iii) in any current or future medium and for any number of copies, and (iv) for any purpose whatsoever, including without limitation commercial, advertising or promotional purposes (the “License”). The License shall be deemed effective as of the date CC0 was applied by Affirmer to the Work. Should any part of the License for any reason be judged legally invalid or ineffective under applicable law, such partial invalidity or ineffectiveness shall not invalidate the remainder of the License, and in such case Affirmer hereby affirms that he or she will not (i) exercise any of his or her remaining Copyright and Related Rights in the Work or (ii) assert any associated claims and causes of action with respect to the Work, in either case contrary to Affirmer’s express Statement of Purpose.\nLimitations and Disclaimers.\n\n\n\nNo trademark or patent rights held by Affirmer are waived, abandoned, surrendered, licensed or otherwise affected by this document.\nAffirmer offers the Work as-is and makes no representations or warranties of any kind concerning the Work, express, implied, statutory or otherwise, including without limitation warranties of title, merchantability, fitness for a particular purpose, non infringement, or the absence of latent or other defects, accuracy, or the present or absence of errors, whether or not discoverable, all to the greatest extent permissible under applicable law.\nAffirmer disclaims responsibility for clearing rights of other persons that may apply to the Work or any use thereof, including without limitation any person’s Copyright and Related Rights in the Work. Further, Affirmer disclaims responsibility for obtaining any necessary consents, permissions or other rights required for any use of the Work.\nAffirmer understands and acknowledges that Creative Commons is not a party to this document and has no duty or obligation with respect to this CC0 or use of the Work."
  },
  {
    "objectID": "10_exportacion.html#guardar-en-formatos-pdf-y-png",
    "href": "10_exportacion.html#guardar-en-formatos-pdf-y-png",
    "title": "13  Exportación de resultados",
    "section": "13.2 Guardar en formatos PDF y PNG",
    "text": "13.2 Guardar en formatos PDF y PNG\nSi no se especifica el argumento plot, la función ggsave() guardará automáticamente el último gráfico creado en la sesión de R. Esto es útil cuando se trabaja de manera interactiva y se desea guardar rápidamente un gráfico sin asignarlo a un objeto. A continuación, se describen los pasos para exportar gráficos en formatos PNG y PDF, junto con un ejemplo.\n\n13.2.1 Crear un gráfico con ggplot2\nAntes de guardar un gráfico, es necesario crearlo. A continuación, se presenta un ejemplo de un gráfico creado con ggplot2:\n\n# Instalación y carga de paquetes esenciales\n\n# Paquete que incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Importar la base de datos\ndatos &lt;- read_csv(\"datos_estudiantes.csv\")\n\n# Ejemplo avanzado de personalización de un gráfico\nplot&lt;- ggplot(data = datos, aes(x = FACULTAD)) +\n  geom_bar(fill = \"steelblue\", color = \"black\", alpha = 0.8) +\n  labs(\n    title = \"Distribución de estudiantes por facultad\",\n    subtitle = \"Datos del estudio de 2002, \n    Universidad de San Carlos de Guatemala\",\n    x = \"Facultad\",\n    y = \"Cantidad de estudiantes\",\n    caption = \"Fuente: Estudio realizado en 2002\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 12, hjust = 0.5, color = \"gray50\"),\n    axis.title = element_text(size = 12, face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.caption = element_text(hjust = 0, size = 8, color = \"gray50\")\n  )\n\n\n\n13.2.2 Guardar el gráfico en formato PNG\nUna vez creado el gráfico, se puede guardar utilizando ggsave():\n\n# Guardar el gráfico en formato PNG\nggsave(\"grafico.png\", width = 8, height = 6, dpi = 300)\n\n\nfilename: Nombre del archivo de salida (en este caso, \"grafico.png\").\nplot: Objeto del gráfico que se desea guardar.\nwidth y height: Dimensiones del gráfico en pulgadas.\ndpi: Resolución del archivo en puntos por pulgada (300 dpi es adecuado para impresión).\n\n\n\n13.2.3 Guardar en Formato PDF\nEl formato PDF es ideal para gráficos que requieren escalado sin pérdida de calidad, como en publicaciones científicas o informes.\n\n# Guardar el gráfico en formato PDF\nggsave(\"grafico.pdf\", width = 8, height = 6)\n\nDiferencias con PNG: No es necesario especificar la resolución (dpi), ya que el formato PDF es vectorial y no depende de la resolución.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Exportación de resultados</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducción al entorno de programacón R y su aplicación en el análisis estadístico de datos",
    "section": "",
    "text": "Introducción\nLa estadística clásica es una disciplina fundamental en la investigación científica y en la toma de decisiones basada en datos. Este manual está diseñado para principiantes y busca introducir las herramientas fundamentales de R, un lenguaje ampliamente utilizado en el análisis estadístico y la ciencia de datos. A lo largo del manual, se abordan conceptos básicos acompañados de ejemplos prácticos que facilitan su comprensión y aplicación en diversos contextos. El objetivo es proporcionar una base sólida que permita aplicar R de manera efectiva en el análisis de datos, incluso sin experiencia previa.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#propósito-del-manual",
    "href": "index.html#propósito-del-manual",
    "title": "Introducción al entorno de programacón R y su aplicación en el análisis estadístico de datos",
    "section": "Propósito del manual",
    "text": "Propósito del manual\nEl presente manual está diseñado para guiar a principiantes en el uso del lenguaje de programación R, desde su instalación y configuración hasta la aplicación de técnicas estadísticas clásicas. Se abordan temas como la manipulación de datos, la creación de gráficos y la realización de análisis estadísticos básicos. Además, se incluyen ejemplos prácticos que permiten aplicar los conceptos aprendidos en contextos reales.\nR, como herramienta de código abierto, se ha consolidado como un estándar en el análisis estadístico y la ciencia de datos, gracias a su flexibilidad, extensibilidad y capacidad para garantizar la reproducibilidad científica (Ihaka & Gentleman, 1996; R Core Team, 2023). A lo largo de este texto, se exploran las principales características de R y su entorno de desarrollo integrado (IDE), RStudio, destacando su utilidad en proyectos académicos y profesionales. Este manual está dirigido a estudiantes, investigadores y profesionales interesados en adquirir habilidades en programación estadística, con un enfoque en la claridad, organización y reproducibilidad.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#organización-del-manual",
    "href": "index.html#organización-del-manual",
    "title": "Introducción al entorno de programacón R y su aplicación en el análisis estadístico de datos",
    "section": "Organización del manual",
    "text": "Organización del manual\nEl contenido del manual está estructurado de manera progresiva, comenzando con los conceptos más básicos y avanzando hacia herramientas y técnicas estadísticas más complejas. Cada sección incluye explicaciones claras, ejemplos prácticos y ejercicios que permiten aplicar lo aprendido. Además, se han incorporado recomendaciones y buenas prácticas para facilitar el aprendizaje y fomentar la reproducibilidad en los análisis.\nEl manual se organiza en los siguientes capítulos principales:\n\nIntroducción a R y RStudio: Se presenta qué es R, sus características principales y cómo instalar tanto R como RStudio. También se explica cómo configurar el entorno de trabajo.\nConceptos básicos de R: Se abordan los fundamentos del lenguaje, como la creación de objetos, tipos de datos y operadores.\nManipulación de datos: Se introduce el uso de herramientas como dplyr y tidyr para transformar y organizar datos de manera eficiente.\nVisualización de datos: Se enseña a crear gráficos básicos y personalizados utilizando el paquete ggplot2.\nExportación de resultados: Se explica cómo guardar gráficos, tablas y otros resultados en formatos útiles para informes y presentaciones.\nMaterial de apoyo y referencias: Se incluyen recursos adicionales para profundizar en el aprendizaje de R.\nEjemplos de análisis estadístico con R: Se desarrollan de manera detallada ejemplos del uso de R para desarrollar análisis estadístico de datos.\n\nCada capítulo está diseñado para ser independiente, permitiendo que los lectores avancen a su propio ritmo y consulten las secciones según sus necesidades.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#pre-requisitos",
    "href": "index.html#pre-requisitos",
    "title": "Introducción al entorno de programacón R y su aplicación en el análisis estadístico de datos",
    "section": "Pre requisitos",
    "text": "Pre requisitos\nEste manual no requiere conocimientos previos en programación ni en análisis estadístico. Está diseñado específicamente para principiantes, por lo que se parte desde cero, explicando cada concepto de manera clara y detallada. Todo lo que se necesita es:\n\nInterés por aprender: La curiosidad y disposición para explorar un nuevo lenguaje de programación.\nAcceso a una computadora: Con capacidad para instalar R y RStudio, herramientas que se explican paso a paso en el manual.\nPaciencia y práctica: Como cualquier habilidad nueva, aprender R requiere tiempo y dedicación. Los ejemplos y ejercicios incluidos están diseñados para facilitar este proceso.\n\nCon este enfoque, cualquier persona, independientemente de su experiencia previa, podrá utilizar este manual como una guía para iniciarse en el análisis estadístico con R.",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "index.html#colofón",
    "href": "index.html#colofón",
    "title": "Introducción al entorno de programacón R y su aplicación en el análisis estadístico de datos",
    "section": "Colofón",
    "text": "Colofón\nLa versión en línea de este manual se encuentra disponible en https://introduccion-r-cete.vercel.app/. La fuente del manual en español está alojada en el repositorio de GitHub: https://github.com/Ludwing-MJ/introduccion_R_CETE. Este manual ha sido desarrollado utilizando Quarto, una herramienta diseñada para convertir archivos con extensión .qmd en formatos publicables como HTML, PDF y EPUB.\nEste manual fue construido con:\n\ndevtools::session_info()\n\nWarning in system2(\"quarto\", \"-V\", stdout = TRUE, env = paste0(\"TMPDIR=\", : el\ncomando ejecutado '\"quarto\"\nTMPDIR=C:/Users/Usuario/AppData/Local/Temp/Rtmp25gmTn/file3ec65f82616 -V' tiene\nel estatus 1\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.4.2 (2024-10-31 ucrt)\n os       Windows 11 x64 (build 26100)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  Spanish_Guatemala.utf8\n ctype    Spanish_Guatemala.utf8\n tz       America/Guatemala\n date     2025-04-09\n pandoc   3.2 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n quarto   NA @ C:\\\\Users\\\\Usuario\\\\AppData\\\\Local\\\\Programs\\\\Quarto\\\\bin\\\\quarto.exe\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cachem        1.1.0   2024-05-16 [1] CRAN (R 4.4.2)\n cli           3.6.3   2024-06-21 [1] CRAN (R 4.4.2)\n devtools      2.4.5   2022-10-11 [1] CRAN (R 4.4.3)\n digest        0.6.37  2024-08-19 [1] CRAN (R 4.4.2)\n ellipsis      0.3.2   2021-04-29 [1] CRAN (R 4.4.3)\n evaluate      1.0.3   2025-01-10 [1] CRAN (R 4.4.2)\n fastmap       1.2.0   2024-05-15 [1] CRAN (R 4.4.2)\n fs            1.6.5   2024-10-30 [1] CRAN (R 4.4.2)\n glue          1.8.0   2024-09-30 [1] CRAN (R 4.4.2)\n htmltools     0.5.8.1 2024-04-04 [1] CRAN (R 4.4.2)\n htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.4.3)\n httpuv        1.6.15  2024-03-26 [1] CRAN (R 4.4.3)\n jsonlite      1.8.9   2024-09-20 [1] CRAN (R 4.4.2)\n knitr         1.49    2024-11-08 [1] CRAN (R 4.4.2)\n later         1.4.1   2024-11-27 [1] CRAN (R 4.4.3)\n lifecycle     1.0.4   2023-11-07 [1] CRAN (R 4.4.2)\n magrittr      2.0.3   2022-03-30 [1] CRAN (R 4.4.2)\n memoise       2.0.1   2021-11-26 [1] CRAN (R 4.4.2)\n mime          0.12    2021-09-28 [1] CRAN (R 4.4.0)\n miniUI        0.1.1.1 2018-05-18 [1] CRAN (R 4.4.3)\n pkgbuild      1.4.6   2025-01-16 [1] CRAN (R 4.4.3)\n pkgload       1.4.0   2024-06-28 [1] CRAN (R 4.4.3)\n profvis       0.4.0   2024-09-20 [1] CRAN (R 4.4.3)\n promises      1.3.2   2024-11-28 [1] CRAN (R 4.4.3)\n purrr         1.0.4   2025-02-05 [1] CRAN (R 4.4.2)\n R6            2.5.1   2021-08-19 [1] CRAN (R 4.4.2)\n Rcpp          1.0.14  2025-01-12 [1] CRAN (R 4.4.2)\n remotes       2.5.0   2024-03-17 [1] CRAN (R 4.4.3)\n rlang         1.1.5   2025-01-17 [1] CRAN (R 4.4.2)\n rmarkdown     2.29    2024-11-04 [1] CRAN (R 4.4.2)\n rstudioapi    0.17.1  2024-10-22 [1] CRAN (R 4.4.2)\n sessioninfo   1.2.3   2025-02-05 [1] CRAN (R 4.4.3)\n shiny         1.10.0  2024-12-14 [1] CRAN (R 4.4.3)\n urlchecker    1.0.1   2021-11-30 [1] CRAN (R 4.4.3)\n usethis       3.1.0   2024-11-26 [1] CRAN (R 4.4.3)\n vctrs         0.6.5   2023-12-01 [1] CRAN (R 4.4.2)\n xfun          0.50    2025-01-07 [1] CRAN (R 4.4.2)\n xtable        1.8-4   2019-04-21 [1] CRAN (R 4.4.3)\n\n [1] C:/Users/Usuario/AppData/Local/R/win-library/4.4\n [2] C:/Program Files/R/R-4.4.2/library\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Introducción"
    ]
  },
  {
    "objectID": "regresion_simple.html",
    "href": "regresion_simple.html",
    "title": "21  Regresión lineal simple usando R",
    "section": "",
    "text": "21.1 Conceptos fundamentales\nLa regresión lineal simple es una técnica estadística utilizada para modelar la relación entre una variable dependiente y una variable independiente. Su propósito principal es predecir el valor de la variable dependiente a partir de la variable independiente, lo que permite entender cómo varía una en función de la otra. Esta técnica es fundamental en el análisis estadístico, ya que proporciona una base para la inferencia y la toma de decisiones en diversos campos (Montgomery, Peck, & Vining, 2012).\nPor ejemplo, en economía, la regresión lineal simple puede utilizarse para predecir el consumo en función del ingreso. En biología, se aplica para analizar la relación entre la dosis de un fármaco y la respuesta de un organismo. En ciencias sociales, se utiliza para estudiar cómo factores como la educación influyen en los ingresos de una población (Field, 2013).\nLas variables dependientes son aquellas que se desean predecir o explicar, mientras que las variables independientes son las que se utilizan para realizar dicha predicción. La diferencia radica en que la variable dependiente es el resultado que se estudia, mientras que la variable independiente es el factor que se manipula o se observa (Cohen, Cohen, West, & Aiken, 2003).\nLa relación lineal implica que existe una conexión directa entre las variables, de tal manera que un cambio en la variable independiente produce un cambio proporcional en la variable dependiente.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Regresión lineal simple usando R</span>"
    ]
  },
  {
    "objectID": "regresion_simple.html#modelo-de-regresión-lineal-simple",
    "href": "regresion_simple.html#modelo-de-regresión-lineal-simple",
    "title": "21  Regresión lineal simple usando R",
    "section": "21.2 Modelo de Regresión Lineal Simple",
    "text": "21.2 Modelo de Regresión Lineal Simple\nEl modelo de regresión lineal simple se expresa mediante la siguiente ecuación:\n\n\n\n\n\nEn esta ecuación, Y representa la variable dependiente, X es la variable independiente, ß0 es la intersección (el valor de Y) cuando X) es cero) y ß1 es la pendiente (que indica el cambio en Y) por cada unidad de cambio en X. El término epilson (ε) representa el error del modelo, que captura la variabilidad en Y que no se explica por X (Kutner, Nachtsheim, Neter, & Li, 2005).",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Regresión lineal simple usando R</span>"
    ]
  },
  {
    "objectID": "regresion_simple.html#supuestos-de-la-regresión-lineal",
    "href": "regresion_simple.html#supuestos-de-la-regresión-lineal",
    "title": "21  Regresión lineal simple usando R",
    "section": "21.3 Supuestos de la Regresión Lineal",
    "text": "21.3 Supuestos de la Regresión Lineal\nPara que el modelo de regresión lineal sea válido, es fundamental que se cumplan ciertos supuestos:\n\nLinealidad: La relación entre las variables debe ser lineal.\nIndependencia: Las observaciones deben ser independientes entre sí.\nHomoscedasticidad: La varianza de los errores debe ser constante a lo largo de todos los niveles de X.\nNormalidad: Los errores deben seguir una distribución normal (Tabachnick & Fidell, 2013).",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Regresión lineal simple usando R</span>"
    ]
  },
  {
    "objectID": "regresion_simple.html#evaluación-del-modelo",
    "href": "regresion_simple.html#evaluación-del-modelo",
    "title": "21  Regresión lineal simple usando R",
    "section": "21.4 Evaluación del Modelo",
    "text": "21.4 Evaluación del Modelo\nLa calidad del modelo de regresión lineal simple se evalúa a través de varias métricas:\n\nR-cuadrado: Indica la proporción de la variabilidad en la variable dependiente que es explicada por la variable independiente. Un valor cercano a 1 sugiere un buen ajuste del modelo.\nAnálisis de residuos: Es crucial analizar los residuos para verificar los supuestos del modelo, asegurando que no haya patrones sistemáticos que indiquen un mal ajuste (Belsley, Kuh, & Welsch, 1980).",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Regresión lineal simple usando R</span>"
    ]
  },
  {
    "objectID": "regresion_simple.html#ejemplo-práctico",
    "href": "regresion_simple.html#ejemplo-práctico",
    "title": "21  Regresión lineal simple usando R",
    "section": "21.5 Ejemplo Práctico",
    "text": "21.5 Ejemplo Práctico\nEste ejemplo práctico ilustra cómo realizar un análisis de regresión lineal simple utilizando un conjunto de datos sobre esporofitos. Los datos provienen de un estudio realizado en el laboratorio de cultivo de tejidos de la Facultad de Agronomía de la Universidad de San Carlos de Guatemala. En este estudio, se llevó a cabo la reproducción del helecho conocido como calahuala (Phlebodium pseudoaureum (Cav.) Lellinger).\nSe midió la altura de cada esporofito y se cuantificó la cantidad de esporofitos germinados en 30 frascos que contenían medio de cultivo Murashige y Skoog. Los resultados obtenidos se presentan en el siguiente archivo. Este análisis se basa en la investigación de Rosales Castillo (2005), quien realizó una micropropagación de Calahuala utilizando tres tipos de explantes en diferentes medios de cultivo in vitro.\nEl objetivo de este análisis es evaluar la relación entre la altura de los esporofitos y la cantidad de esporofitos germinados, utilizando la regresión lineal simple como herramienta estadística. A través de este proceso, se busca no solo ajustar un modelo que explique esta relación, sino también verificar los supuestos que sustentan la validez del modelo.\n\n21.5.1 Instalación y Carga de Paquetes\nPara comenzar, es necesario instalar y cargar los paquetes requeridos. Estos paquetes proporcionan funciones útiles para la manipulación de datos y la visualización.\n\n# Instalación y carga de paquetes  \n# Incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Se utiliza para evaluar el supuesto de homocedasticidad\nif (!require(\"car\")) install.packages(\"car\")\n\n# Se utiliza para importar archivos de Excel\nif (!require(\"readxl\")) install.packages(\"readxl\")\n\nExplicación:\n\ntidyverse: Este paquete incluye varias herramientas para la manipulación y visualización de datos, como ggplot2, dplyr y tidyr.\ncar: Proporciona funciones para realizar pruebas de hipótesis y diagnósticos de modelos, incluyendo la evaluación de homocedasticidad.\nreadxl: Permite importar datos desde archivos de Excel, facilitando la carga de conjuntos de datos.\n\n\n\n21.5.2 Importación de Datos\nA continuación, se importan los datos desde un archivo Excel.\n\n# Importar un archivo csv\ndatos &lt;- read_excel(\"esporofitos.xlsx\")\n\n# Visualizar los primeros registros del data frame\nhead(datos)\n\n# A tibble: 6 × 3\n  frasco cantidad_de_esporofitos altura_mm\n   &lt;dbl&gt;                   &lt;dbl&gt;     &lt;dbl&gt;\n1      1                      40      21.4\n2      2                      45      21  \n3      3                      60      20.5\n4      4                      55      20  \n5      5                      58      21  \n6      6                      40      21.7\n\n\nEste código carga el archivo de Excel que contiene los datos sobre esporofitos y muestra las primeras filas del conjunto de datos para verificar que se haya importado correctamente.\n\n\n21.5.3 Visualización de Datos\nSe elabora un gráfico de dispersión para observar la relación entre las variables.\n\n# Elaboración de un gráfico de dispersión entre altura y cantidad\nplot( datos$altura_mm, datos$cantidad_de_esporofitos)\n\n\n\n\n\n\n\n\nEste gráfico permite visualizar la relación entre la cantidad de esporofitos y la altura en milímetros, facilitando la identificación de patrones. Como se puede apreciar en el gráfico anterior hay una relación inversamente proporcional entre la altura de los esporofitos y la cantidad de esporofitos.\n\n\n21.5.4 Ajuste del Modelo de Regresión\nSe ajusta el modelo de regresión lineal simple utilizando la función lm().\n\n# Ajuste del modelo\nregsimple &lt;- lm(datos$altura_mm ~ datos $cantidad_de_esporofitos)\nsummary(regsimple)\n\n\nCall:\nlm(formula = datos$altura_mm ~ datos$cantidad_de_esporofitos)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.78523 -0.15056  0.01664  0.22403  0.62850 \n\nCoefficients:\n                                Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)                   22.8933399  0.1446248  158.29   &lt;2e-16 ***\ndatos$cantidad_de_esporofitos -0.0401248  0.0008826  -45.46   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.3753 on 28 degrees of freedom\nMultiple R-squared:  0.9866,    Adjusted R-squared:  0.9862 \nF-statistic:  2067 on 1 and 28 DF,  p-value: &lt; 2.2e-16\n\n\nEl resumen del modelo ajustado proporciona información sobre los coeficientes, errores estándar y estadísticas de ajuste, permitiendo evaluar la calidad del modelo.\nExplicación del código:\n\nlm(): Esta función ajusta un modelo de regresión lineal donde la cantidad de esporofitos es la variable dependiente y la altura es la variable independiente.\nsummary(regsimple): Proporciona un resumen del modelo ajustado, incluyendo coeficientes, errores estándar y estadísticas de ajuste.\n\n\n\n21.5.5 Gráficos de Diagnóstico para evaluar los supuestos del modelo\nSe generan gráficos de diagnóstico para evaluar los supuestos del modelo.\n\n# Gráficos de diagnóstico de los supuestos\npar(mfrow=c(1,2)) # Crea una matriz de dos gráficos\nplot(regsimple, which=1:2)\n\n\n\n\n\n\n\npar(mfrow=c(1,1)) # Devuelve a su estado normal el área de gráficos\n\nEstos gráficos ayudan a verificar la linealidad y la homocedasticidad, asegurando que los supuestos del modelo se cumplan.\nExplicación del código:\nplot(regsimple, which=1:2): Genera los gráficos de residuos y ajuste, que ayudan a verificar la linealidad y la homocedasticidad.\n\n\n21.5.6 Prueba de Normalidad de los Residuos\nSe realiza la prueba de Shapiro-Wilk para evaluar la normalidad de los residuos.\n\n# Realizar la prueba de Shapiro-Wilk en los residuos\nshapiro.test(residuals(regsimple))\n\n\n    Shapiro-Wilk normality test\n\ndata:  residuals(regsimple)\nW = 0.95651, p-value = 0.2516\n\n\nExplicación:\nshapiro.test(residuals(regsimple)): Esta prueba evalúa si los residuos del modelo siguen una distribución normal. Un valor p bajo ( &lt; 0.05) indica que los residuos no son normales. Para el ejemplo en cuestión el valor de p es de 0.2516 por lo que no se rechaza la hipótesis nula y por lo tanto no hay suficiente evidencia estadística para indica que los residuos no son norales.\n\n\n21.5.7 Prueba de Homocedasticidad de la varianza\nFinalmente, se evalúa el supuesto de homocedasticidad utilizando la prueba de heterocedasticidad.\n\n# Realizar prueba para el supuesto de homocedasticidad\nncvTest(regsimple)\n\nNon-constant Variance Score Test \nVariance formula: ~ fitted.values \nChisquare = 0.07681442, Df = 1, p = 0.78166\n\n\nExplicación:\nncvTest(regsimple): Esta función evalúa si la varianza de los residuos es constante a lo largo de los valores de la variable independiente. Un valor p bajo (&lt;0.05) sugiere que hay heterocedasticidad, lo que puede invalidar el modelo. Para este ejemplo el valor de p es 0.78166 por lo que no hay evidencia estadística suficiente para indicar que la varianza de los residuos no es contante.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Regresión lineal simple usando R</span>"
    ]
  },
  {
    "objectID": "08.3_manipulacion.html",
    "href": "08.3_manipulacion.html",
    "title": "11  Manipulación de datos con dplyr y tidyr",
    "section": "",
    "text": "11.1 Introducción a los paquetes dplyr y tidyr\nLos paquetes dplyr y tidyr son componentes fundamentales del ecosistema tidyverse, diseñados para simplificar y optimizar la manipulación y transformación de datos en R. Estas herramientas permiten realizar tareas comunes de análisis de datos de manera eficiente, reproducible y con una sintaxis clara e intuitiva (Wickham et al., 2023). En esta sección, se explorarán las principales funciones de estos paquetes, junto con ejemplos prácticos que ilustran su uso.\nEl paquete dplyr está especializado en la manipulación de datos tabulares, ofreciendo funciones específicas para realizar operaciones como filtrar filas, seleccionar columnas, crear nuevas variables y resumir datos. Su diseño está optimizado para trabajar con estructuras como data frames y tibbles, proporcionando un rendimiento superior y una sintaxis más legible en comparación con las funciones base de R.\nPor otro lado, el paquete tidyr se centra en la reorganización de datos, facilitando la transformación entre formatos “ancho” y “largo”. Estas transformaciones son esenciales para preparar los datos de manera adecuada antes de su análisis o visualización, asegurando que estén en el formato más conveniente para las herramientas de análisis.\nPara ilustrar el uso de estas herramientas, en esta sección se desarrollará un ejemplo práctico que permitirá explorar las principales funciones de manipulación de datos. El script correspondiente a este ejemplo está disponible en el siguiente repositorio: Repositorio de ejemplo - Manipulación de datos.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "08.3_manipulacion.html#operaciones-básicas-con-dplyr",
    "href": "08.3_manipulacion.html#operaciones-básicas-con-dplyr",
    "title": "11  Manipulación de datos con dplyr y tidyr",
    "section": "11.2 Operaciones básicas con dplyr",
    "text": "11.2 Operaciones básicas con dplyr\n\n11.2.1 Filtrar filas con filter()\nLa función filter() se utiliza para seleccionar filas de un data frame que cumplen con una o más condiciones lógicas. Esta operación es útil para extraer subconjuntos de datos relevantes para un análisis específico.\nSintaxis básica:\n\nfilter(data, condición)\n\nEjemplo práctico: Filtrar estudiantes con un peso mayor a 65 kg.\n\n# Crear un data frame de ejemplo\ndatos &lt;- data.frame(\n  nombre = c(\"Juan\", \"Ana\", \"Luis\", \"María\"),\n  edad = c(18, 22, 20, 19),\n  peso = c(70, 55, 80, 60),\n  altura = c(1.75, 1.60, 1.80, 1.65)\n)\n\n# Filtrar estudiantes con peso mayor a 65 kg\nestudiantes_pesados &lt;- datos %&gt;% \n  filter(peso &gt; 65)\n\n# Visualizar el resultado\nestudiantes_pesados\n\n  nombre edad peso altura\n1   Juan   18   70   1.75\n2   Luis   20   80   1.80\n\n\nExplicación: El resultado es un data frame que incluye únicamente las filas donde la variable peso es mayor a 65. Esta operación permite enfocar el análisis en un subconjunto específico de datos, lo que resulta útil en estudios que requieren segmentación de información.\n\n\n11.2.2 Seleccionar columnas con select()\nLa función select() permite extraer columnas específicas de un data frame. Esto es útil para reducir la cantidad de datos visibles o para trabajar únicamente con las variables necesarias.\nSintaxis básica:\n\nselect(data, columnas)\n\nEjemplo práctico: Seleccionar las columnas nombre y edad.\n\n# Seleccionar columnas específicas\ndatos_reducidos &lt;- datos %&gt;%\n  select(nombre, edad)\n\n# Visualizar el resultado\ndatos_reducidos\n\n  nombre edad\n1   Juan   18\n2    Ana   22\n3   Luis   20\n4  María   19\n\n\nExplicación: El resultado es un data frame que contiene únicamente las columnas nombre y edad. Esto es especialmente útil cuando se desea exportar información específica o simplificar la visualización de los datos.\n\n\n11.2.3 Crear nuevas columnas con mutate()\nLa función mutate() permite añadir nuevas columnas calculadas a un data frame. Esta operación es esencial para realizar cálculos derivados de las variables existentes.\nSintaxis básica:\n\nmutate(data, nueva_columna = expresión)\n\nEjemplo práctico: Calcular el índice de masa corporal (IMC) de los estudiantes.\n\n# Calcular el IMC\ndatos &lt;- datos %&gt;%\n  mutate(IMC = peso / (altura^2))\n\n# Visualizar el resultado\ndatos\n\n  nombre edad peso altura      IMC\n1   Juan   18   70   1.75 22.85714\n2    Ana   22   55   1.60 21.48437\n3   Luis   20   80   1.80 24.69136\n4  María   19   60   1.65 22.03857\n\n\nExplicación: Se añade una nueva columna llamada IMC al data frame, calculada como el peso dividido por el cuadrado de la altura. Esta operación permite enriquecer los datos con información derivada, facilitando análisis más detallados.\n\n\n11.2.4 Agrupar y resumir datos con group_by() y summarize()\nLa combinación de group_by() y summarize() permite calcular estadísticas por grupo. Esto es útil para obtener resúmenes de datos categorizados, como promedios, sumas o conteos.\nSintaxis básica:\n\n  data %&gt;%\n  group_by(grupo) %&gt;%\n  summarize(resumen = función(variable))\n\nEjemplo práctico: Calcular el peso promedio por grupo de edad (mayores y menores de 20 años).\n\n# Calcular peso promedio por grupo de edad\npeso_promedio &lt;- datos %&gt;%\n  mutate(grupo_edad = ifelse(edad &gt;= 20, \n                             \"Mayor o igual a 20\", \n                             \"Menor a 20\")) %&gt;%\n  group_by(grupo_edad) %&gt;%\n  summarize(peso_promedio = mean(peso))\n\n# Visualizar el resultado\npeso_promedio\n\n# A tibble: 2 × 2\n  grupo_edad         peso_promedio\n  &lt;chr&gt;                      &lt;dbl&gt;\n1 Mayor o igual a 20          67.5\n2 Menor a 20                  65  \n\n\nExplicación: Se crea una nueva variable grupo_edad que clasifica a los estudiantes en dos categorías: “Mayor o igual a 20” y “Menor a 20”. Luego, se calcula el peso promedio para cada grupo. Este tipo de operación es útil para realizar análisis comparativos entre categorías, como estudios demográficos o segmentación de datos.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "08.3_manipulacion.html#uso-de-pipes-para-mejorar-la-legibilidad-del-código",
    "href": "08.3_manipulacion.html#uso-de-pipes-para-mejorar-la-legibilidad-del-código",
    "title": "11  Manipulación de datos con dplyr y tidyr",
    "section": "11.3 Uso de pipes (%>%) para mejorar la legibilidad del código",
    "text": "11.3 Uso de pipes (%&gt;%) para mejorar la legibilidad del código\nEl operador pipe (%&gt;%), introducido por el paquete magrittr y ampliamente adoptado en el ecosistema tidyverse, permite encadenar funciones de manera legible. En lugar de anidar funciones, el pipe pasa el resultado de una función como entrada a la siguiente.\nEjemplo sin pipes: Cuando no se utiliza el operador pipe, las funciones deben anidarse o ejecutarse en pasos separados, lo que puede dificultar la lectura y comprensión del código:\n\n# Crear columna grupo_edad usando mutate\ndatos &lt;- datos %&gt;%\n  mutate(grupo_edad = ifelse(edad &gt;= 20, \n                             \"Mayor o igual a 20\", \n                             \"Menor a 20\")) \n# Agrupar y resumir los datos sin pipes\nresultado &lt;- summarize(group_by(datos, grupo_edad),\n                       peso_promedio = mean(peso))\n\nEjemplo con pipes: El uso de pipes permite encadenar las operaciones de manera más clara y natural, eliminando la necesidad de anidar funciones:\n\n# Agrupar y resumir los datos con pipes\nresultado &lt;- datos %&gt;%   \n  group_by(grupo_edad) %&gt;%   \n  summarize(peso_promedio = mean(peso))\n\nDiferencia clave: Con pipes, el flujo de trabajo se lee de arriba hacia abajo, siguiendo un orden lógico que refleja el proceso de análisis.\n\n11.3.1 Ventajas del uso de pipes\nEl uso de pipes (%&gt;%) en R mejora significativamente la legibilidad del código al permitir que las operaciones se encadenen de manera secuencial y lógica, eliminando la necesidad de anidar funciones. Esto facilita la comprensión del flujo de trabajo, especialmente en análisis complejos. Además, los pipes simplifican la depuración, ya que dividen el análisis en pasos claros, lo que permite identificar errores y verificar resultados intermedios con mayor facilidad.\nOtra ventaja clave es la modularidad, ya que cada operación se organiza como un bloque independiente, lo que facilita realizar ajustes sin afectar el resto del análisis. Finalmente, los pipes promueven la reproducibilidad, al estructurar el código de forma clara y reutilizable, mejorando la colaboración y asegurando resultados consistentes.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "08.3_manipulacion.html#transformación-de-datos-con-tidyr",
    "href": "08.3_manipulacion.html#transformación-de-datos-con-tidyr",
    "title": "11  Manipulación de datos con dplyr y tidyr",
    "section": "11.4 Transformación de datos con tidyr",
    "text": "11.4 Transformación de datos con tidyr\nEl paquete tidyr es una herramienta fundamental para la reorganización de datos en R, especialmente cuando se necesita cambiar entre formatos “ancho” y “largo”. Esta transformación es esencial para adaptar los datos a diferentes tipos de análisis estadísticos y visualizaciones (Wickham & Grolemund, 2017).\n\n11.4.1 ¿Qué son los formatos ancho y largo?\nFormato ancho: Cada variable tiene su propia columna, y cada observación está en una sola fila.\nFormato largo: Las variables están organizadas en pares de columnas (nombre de variable y valor), con múltiples filas por observación.\n\n\n11.4.2 Funciones principales de transformación\n\npivot_longer(): se utiliza para transformar datos de formato ancho a largo. Este tipo de transformación es especialmente útil cuando se necesita trabajar con datos en los que cada observación debe ocupar una fila, mientras que las variables se representan en columnas separadas. Por ejemplo, es ideal para crear gráficos con múltiples series, ya que facilita la comparación entre diferentes variables en un mismo análisis. Además, este formato es requerido en muchos análisis estadísticos que trabajan con datos agrupados, como ANOVA o modelos de regresión, donde las variables deben estar organizadas en un formato más estructurado.\npivot_wider(): realiza la transformación inversa, es decir, convierte datos de formato largo a ancho. Este tipo de transformación es útil cuando se necesita crear tablas resumen que presenten los datos de manera más compacta y legible. También es esencial para análisis que requieren que las variables estén en columnas separadas, como cálculos de correlación o regresiones específicas. Además, el formato ancho es más adecuado para la presentación de resultados en reportes o tablas, ya que permite visualizar de forma clara las relaciones entre las variables y las observaciones.\n\n\n\n11.4.3 Ejemplo práctico\nPara ilustrar el uso de las funciones de transformación de datos, consideremos un ejemplo práctico con calificaciones de estudiantes. Inicialmente, crearemos un conjunto de datos que contiene las calificaciones de tres estudiantes en dos materias diferentes:\n\n# Crear data frame de calificaciones\ncalificaciones &lt;- data.frame(\n  nombre = c(\"Juan\", \"Ana\", \"Luis\"),\n  matematicas = c(85, 90, 78),\n  ciencias = c(88, 92, 80)\n)\n\n# Visualizar el data frame original\nprint(\"Datos originales en formato ancho:\")\n\n[1] \"Datos originales en formato ancho:\"\n\ncalificaciones\n\n  nombre matematicas ciencias\n1   Juan          85       88\n2    Ana          90       92\n3   Luis          78       80\n\n\nEn este formato, cada fila representa a un estudiante y las calificaciones de las materias están organizadas en columnas. Sin embargo, para ciertos análisis estadísticos o visualizaciones, es necesario transformar los datos a un formato largo.\n\n11.4.3.1 Transformar de formato ancho a largo\nLa función pivot_longer() permite reorganizar los datos para que cada combinación de estudiante y materia ocupe una fila independiente. Este formato es útil para análisis que requieren datos agrupados o para la creación de gráficos comparativos:\n\n# Transformar a formato largo\ncalificaciones_largo &lt;- calificaciones %&gt;%\n  pivot_longer(\n    cols = c(matematicas, ciencias),    # Columnas a transformar\n    names_to = \"materia\",               # Nueva columna para nombres de materias\n    values_to = \"calificacion\"          # Nueva columna para calificaciones\n  )\n\nprint(\"Datos en formato largo:\")\n\n[1] \"Datos en formato largo:\"\n\ncalificaciones_largo\n\n# A tibble: 6 × 3\n  nombre materia     calificacion\n  &lt;chr&gt;  &lt;chr&gt;              &lt;dbl&gt;\n1 Juan   matematicas           85\n2 Juan   ciencias              88\n3 Ana    matematicas           90\n4 Ana    ciencias              92\n5 Luis   matematicas           78\n6 Luis   ciencias              80\n\n\nEn este formato, cada fila representa una observación única de estudiante y materia, lo que facilita la comparación entre variables, el cálculo de estadísticas por grupo y la preparación de datos para visualizaciones.\n\n\n11.4.3.2 Transformar de formato largo a ancho\nCuando se requiere regresar al formato original, por ejemplo, para presentar los datos en una tabla resumen, se utiliza la función pivot_wider(). Esta función reorganiza los datos para que las materias vuelvan a ocupar columnas separadas:\n\n# Transformar de vuelta a formato ancho\ncalificaciones_ancho &lt;- calificaciones_largo %&gt;%\n  pivot_wider(\n    names_from = \"materia\",            # Columna que se convertirá en nombres de columnas\n    values_from = \"calificacion\"       # Columna que contiene los valores\n  )\n\nprint(\"Datos restaurados en formato ancho:\")\n\n[1] \"Datos restaurados en formato ancho:\"\n\ncalificaciones_ancho\n\n# A tibble: 3 × 3\n  nombre matematicas ciencias\n  &lt;chr&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 Juan            85       88\n2 Ana             90       92\n3 Luis            78       80\n\n\nEsta transformación permite restaurar el formato original, donde cada estudiante ocupa una fila y las materias están organizadas en columnas. Este formato es adecuado para reportes, análisis que requieren variables en columnas independientes o para la presentación de datos de manera más legible.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Manipulación de datos con dplyr y tidyr</span>"
    ]
  },
  {
    "objectID": "11.1_M_apoyo.html",
    "href": "11.1_M_apoyo.html",
    "title": "18  Material de apoyo",
    "section": "",
    "text": "Tutorial en YouTube “Cómo instalar R y RStudio en menos de 2 minutos - 2024”. Elaborado por Herbert Lizama.\nR para ciencia de datos por Handley Wickham & Garrett Grolemund\nRegresión lineal usando R.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Material de apoyo</span>"
    ]
  },
  {
    "objectID": "09.1_visualizacion.html",
    "href": "09.1_visualizacion.html",
    "title": "12  Introducción a la visualización de datos",
    "section": "",
    "text": "12.1 Notas:\nEn esta sección se explicara tanto por que R es una herramienta muy poderosa en la elaboración de gráficos como se hara una introducción de conceptos necesarios para comprender la seccion de visualizacionen de R entera",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Introducción a la visualización de datos</span>"
    ]
  },
  {
    "objectID": "09.2_visualizacion.html",
    "href": "09.2_visualizacion.html",
    "title": "13  Visualizaciones Base de R",
    "section": "",
    "text": "13.1 Notas:\nEn esta sección se explicara tanto por que R es una herramienta muy poderosa en la elaboración de gráficos como se hara una introducción de conceptos necesarios para comprender la seccion de visualizacionen de R entera",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Visualizaciones Base de R</span>"
    ]
  },
  {
    "objectID": "09.3_visualizacion.html",
    "href": "09.3_visualizacion.html",
    "title": "14  Visualización de datos con ggplot2",
    "section": "",
    "text": "14.1 Contexto de la base de datos utilizada\nLa visualización de datos es una herramienta esencial en el análisis estadístico, ya que permite explorar patrones, identificar relaciones y comunicar resultados de manera efectiva. En R, el paquete ggplot2 es ampliamente reconocido por su flexibilidad y capacidad para generar gráficos de alta calidad. Este capítulo aborda los conceptos básicos de ggplot2, la creación de gráficos comunes y las opciones de personalización disponibles, utilizando como ejemplo un conjunto de datos recopilado en un estudio realizado en la Universidad de San Carlos de Guatemala en 2002.\nEl estudio mencionado recopiló información de 460 estudiantes de diversas facultades, incluyendo variables como facultad, edad, sexo, estado civil, jornada de estudio, año de ingreso, peso, talla y hábitos como fumar o consumo de alcohol. Este conjunto de datos, disponible en formato CSV, será utilizado para ilustrar las herramientas y conceptos desarrollados en esta sección. El archivo puede descargarse desde el siguiente repositorio: GitHub - Visualización de datos.\nNota: Es necesario descargar el archivo y guardarlo en la carpeta correspondiente al proyecto en curso para ejecutar los ejemplos.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "09.3_visualizacion.html#introducción-al-paquete-ggplot2",
    "href": "09.3_visualizacion.html#introducción-al-paquete-ggplot2",
    "title": "14  Visualización de datos con ggplot2",
    "section": "14.2 Introducción al paquete ggplot2",
    "text": "14.2 Introducción al paquete ggplot2\nEl paquete ggplot2 es una herramienta versátil y poderosa para la visualización de datos en R. Su diseño modular basado en capas permite construir gráficos de calidad profesional, adaptándose tanto a visualizaciones simples como a gráficos complejos. Además, su integración con el ecosistema tidyverse facilita los flujos de trabajo al combinarse con herramientas como dplyr y tidyr para la manipulación de datos (Wickham, 2016).\nEntre las principales características de ggplot2 se encuentran:\n\nFlexibilidad: Compatible con una amplia variedad de tipos de gráficos, como gráficos de barras, líneas, puntos, histogramas y diagramas de cajas.\nPersonalización: Permite ajustar elementos como colores, etiquetas, temas y escalas.\nExtensibilidad: Puede ampliarse mediante paquetes adicionales, como ggthemes para temas personalizados o plotly para gráficos interactivos.\nComunidad activa: Su extensa documentación y comunidad de usuarios facilitan el aprendizaje y la resolución de problemas.\n\n\n14.2.1 Estructura básica de un gráfico en ggplot2\nLa creación de gráficos en ggplot2 sigue una estructura modular que permite construir visualizaciones de manera flexible y escalable. La sintaxis general es la siguiente:\n\nggplot(data = DATOS, aes(x = VARIABLE_X, y = VARIABLE_Y)) +\n  GEOM_FUNCION() +\n  labs(title = \"Título del gráfico\",\n       x = \"Etiqueta eje X\",\n       y = \"Etiqueta eje Y\")\n\nComponentes principales:\n\ndata: Este argumento define el conjunto de datos que se utilizará para construir el gráfico. Debe ser un data frame o un objeto compatible con este formato. Es el punto de partida para cualquier visualización, ya que contiene las variables que se representarán gráficamente.\naes(): La función aes() (abreviatura de aesthetics) especifica el mapeo estético, es decir, cómo las variables del conjunto de datos se asignan a los elementos visuales del gráfico. Algunos de los mapeos más comunes incluyen:\nx: Variable asignada al eje horizontal.\ny: Variable asignada al eje vertical.\ncolor: Variable que define el color de los elementos.\nsize: Variable que define el tamaño de los elementos.\nshape: Variable que define la forma de los puntos (en gráficos de dispersión, por ejemplo).\nfill: Variable que define el color de relleno (en gráficos como barras o áreas).\nGEOM_FUNCION(): La función geométrica (geom_) define el tipo de gráfico que se desea crear. Cada tipo de gráfico tiene su propia función en ggplot2, como:\ngeom_point(): Gráfico de puntos (dispersión).\ngeom_bar(): Gráfico de barras.\ngeom_line(): Gráfico de líneas.\ngeom_histogram(): Histograma.\ngeom_boxplot(): Diagrama de cajas (boxplot).\nlabs(): La función labs() se utiliza para añadir etiquetas y títulos al gráfico. Esto incluye:\ntitle: Título principal del gráfico.\nx: Etiqueta del eje X.\ny: Etiqueta del eje Y.\nsubtitle: Subtítulo del gráfico.\ncaption: Texto adicional, como la fuente de los datos.\nOperador +: El operador + es fundamental en ggplot2, ya que permite combinar diferentes capas (layers) en un gráfico. Cada capa puede añadir elementos adicionales, como líneas de tendencia, etiquetas o temas personalizados.\n\nPersonalización adicional:\nAdemás de los elementos básicos, ggplot2 permite personalizar los gráficos mediante:\n\nTemas: La función theme() ajusta el diseño general del gráfico, como el tamaño de las fuentes, los colores de fondo y la posición de las leyendas.\nEscalas: Las funciones scale_ permiten modificar los colores, tamaños y formas de los elementos gráficos.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "09.3_visualizacion.html#creación-de-gráficos-básicos",
    "href": "09.3_visualizacion.html#creación-de-gráficos-básicos",
    "title": "14  Visualización de datos con ggplot2",
    "section": "14.3 Creación de gráficos básicos",
    "text": "14.3 Creación de gráficos básicos\nA continuación, se presentan ejemplos de gráficos comunes que se pueden crear con ggplot2, junto con su sintaxis y una explicación detallada. Antes de proceder con la creación de gráficos, es fundamental importar la base de datos y cargar los paquetes necesarios. A continuación, se muestra cómo realizar estos pasos:\n\n14.3.1 Importación de la base de datos\n\n# Ejemplo práctico: Uso de paquetes para visualización\n# NOTA: Antes de trabajar, es necesario crear y guardar un nuevo script.\n\n# Instalación y carga de paquetes esenciales\n\n# Paquete que incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Paquete para establecer el directorio de trabajo automáticamente\nif (!require(\"rstudioapi\")) install.packages(\"rstudioapi\")\n\n# Importar la base de datos\ndatos &lt;- read_csv(\"datos_estudiantes.csv\")\n\n# Ver las primeras filas del conjunto de datos\nhead(datos)\n\nExplicación del código:\n\nInstalación y carga de paquetes: Se utiliza la función if (!require (...)) para verificar si los paquetes están instalados. Si no lo están, se instalan automáticamente con install.packages(). Automáticamente, se cargan. El paquete tidyverse incluye herramientas esenciales para la manipulación y visualización de datos, como ggplot2, dplyr y tidyr. El paquete rstudioapi permite establecer el directorio de trabajo automáticamente, lo que facilita la organización de los archivos.\nEstablecimiento del directorio de trabajo: La función setwd() establece el directorio de trabajo en la ubicación del script actual, utilizando rstudioapi::getActiveDocumentContext()$path. Esto asegura que los archivos se encuentren en la misma carpeta que el script, mejorando la reproducibilidad.\nImportación de datos: La función read_csv() del paquete readr se utiliza para leer archivos CSV. La función head() permite visualizar las primeras filas del conjunto de datos, proporcionando una vista previa de su estructura.\n\n\n14.3.1.1 Notas importantes\n\nEs fundamental asegurarse de que el archivo datos_estudiantes.csv esté ubicado en el directorio de trabajo establecido.\nSi el archivo no se encuentra en el directorio especificado, se generará un error. En ese caso, se puede verificar la ubicación del archivo con getwd() o establecer manualmente el directorio con setwd(\"ruta/del/directorio\").\n\n\n\n\n14.3.2 Histogramas\nLos histogramas son gráficos que permiten visualizar la distribución de una variable numérica, mostrando cómo se agrupan los valores en intervalos específicos. Son útiles para identificar patrones, como la simetría, la dispersión, la presencia de valores atípicos o la forma general de la distribución (e.g., normal, sesgada, etc.).\n\n14.3.2.1 Ejemplo práctico: Creación de un histograma\nEl siguiente código muestra cómo crear un histograma utilizando ggplot2 para explorar la distribución del peso de los estudiantes:\n\n# Ejemplo práctico: Creación de un histograma\nggplot(data = datos, aes(x = PESO_lbs)) +\n  geom_histogram(binwidth = 5, fill = \"skyblue\", color = \"black\") +\n  labs(title = \"Distribución del peso de los estudiantes\",\n       x = \"Peso (libras)\",\n       y = \"Frecuencia\")\n\n\n\n\n\n\n\n\nExplicación del código:\n\nggplot(data = datos, aes(x = PESO_lbs)): Se define el conjunto de datos (datos) y se especifica la variable numérica que se desea analizar (PESO_lbs) dentro de la función aes(). Esta variable se asigna al eje X, ya que el histograma representa la frecuencia de los valores en este eje.\ngeom_histogram(): Esta función geométrica es la encargada de crear el histograma. Cada barra representa la frecuencia de los valores que caen dentro de un intervalo específico.\nArgumento binwidth: El parámetro binwidth define el ancho de los intervalos (o “bins”) en los que se agrupan los datos. En este caso, se establece un ancho de 5 unidades, lo que significa que cada barra del histograma abarca un rango de 5 libras.\nUn valor más pequeño de binwidth genera más barras, proporcionando mayor detalle, mientras que un valor más grande agrupa los datos en menos barras, mostrando una visión más general.\nArgumentos fill y color:\nfill: Define el color de relleno de las barras. En este ejemplo, se utiliza el color “skyblue” para un diseño visualmente atractivo.\ncolor: Define el color del borde de las barras, que en este caso es negro (“black”). Esto ayuda a diferenciar claramente las barras entre sí.\nlabs(): La función labs() se utiliza para añadir etiquetas descriptivas al gráfico:\ntitle: Título principal del gráfico, que describe el propósito del histograma.\nx: Etiqueta del eje X, que indica la variable representada (en este caso, el peso en libras).\ny: Etiqueta del eje Y, que muestra la frecuencia de los valores.\n\n\n\n\n14.3.3 Gráficos de barras\nLos gráficos de barras son ideales para representar datos categóricos, mostrando la frecuencia o el conteo de observaciones en cada categoría. Este tipo de gráfico es útil para comparar grupos o categorías de manera visual y sencilla.\n\n14.3.3.1 Ejemplo práctico: Creación de un gráfico de barras\nEl siguiente código muestra cómo crear un gráfico de barras utilizando ggplot2 para analizar la distribución de estudiantes según su jornada:\n\n# Ejemplo práctico: Creación de un gráfico de barras\nggplot(data = datos, aes(x = JORNADA)) +\n  geom_bar(fill = \"orange\", color = \"black\") +\n  labs(title = \"Distribución de estudiantes por jornada\",\n       x = \"Jornada\",\n       y = \"Frecuencia\")\n\n\n\n\n\n\n\n\nExplicación del código:\n\nggplot(data = datos, aes(x = JORNADA)): Se define el conjunto de datos (datos) y se especifica la variable categórica JORNADA dentro de la función aes(). Esta variable se asigna al eje X, ya que el gráfico de barras representa las categorías en este eje.\ngeom_bar(): Esta función geométrica genera el gráfico de barras. Por defecto, geom_bar() cuenta automáticamente las observaciones en cada categoría de la variable especificada en el eje X.\nArgumentos fill y color:\nfill: Define el color de relleno de las barras. En este ejemplo, se utiliza el color “orange” para un diseño llamativo.\ncolor: Define el color del borde de las barras, que en este caso es negro (“black”). Esto ayuda a resaltar las barras y separarlas visualmente.\n\n\n\n\n14.3.4 Gráficos de dispersión (scatterplots)\nLos gráficos de dispersión son herramientas visuales que permiten analizar la relación entre dos variables numéricas. Cada punto en el gráfico representa una observación, donde la posición en el eje X corresponde al valor de una variable y la posición en el eje Y al valor de la otra. Este tipo de gráfico es útil para identificar patrones, tendencias, correlaciones y posibles valores atípicos.\n\n14.3.4.1 Ejemplo práctico: Creación de un gráfico de dispersión\nEl siguiente código muestra cómo crear un gráfico de dispersión utilizando ggplot2 para explorar la relación entre la talla y el peso de los estudiantes:\n\n# Ejemplo práctico: Creación de un gráfico de dispersión\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point(color = \"red\", size = 2) +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\n\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)): Se define el conjunto de datos (datos) y se especifican las variables numéricas que se desean analizar:\nTALLA: Variable asignada al eje X (talla en metros).\nPESO_lbs: Variable asignada al eje Y (peso en libras).\ngeom_point(): Esta función geométrica dibuja los puntos en el gráfico, representando cada observación del conjunto de datos.\nArgumentos color y size:\ncolor: Define el color de los puntos. En este ejemplo, los puntos se dibujan en rojo (“red”).\nsize: Define el tamaño de los puntos. Aquí se establece un tamaño de 2 para que los puntos sean más visibles.\n\n\n\n\n14.3.5 Boxplots\nLos boxplots (o diagramas de caja y bigotes) son gráficos que permiten visualizar la distribución de una variable numérica y compararla entre diferentes grupos categóricos. Este tipo de gráfico es útil para identificar la mediana, la dispersión, los valores atípicos y la simetría de los datos dentro de cada grupo.\n\n14.3.5.1 Ejemplo práctico: Creación de un boxplot\nEl siguiente código muestra cómo crear un boxplot utilizando ggplot2 para analizar la distribución del peso de los estudiantes según su sexo:\n\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)) +\n  geom_boxplot() +\n  labs(title = \"Distribución del peso por sexo\",\n       x = \"Sexo\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\nExplicación del código\n\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)): Se define el conjunto de datos (datos) y se especifican las variables:\nSEXO: Variable categórica asignada al eje X, que define los grupos a comparar.\nPESO_lbs: Variable numérica asignada al eje Y, cuya distribución se analiza dentro de cada grupo.\nfill: Argumento opcional que asigna un color de relleno diferente a cada grupo basado en la variable SEXO.\ngeom_boxplot(): Esta función geométrica genera el boxplot. Cada caja representa la distribución de la variable numérica dentro de un grupo categórico.\n\n\n\n14.3.5.2 Elementos clave de un boxplot\nUn boxplot incluye los siguientes elementos visuales:\n\nCaja (box): Representa el rango intercuartílico (IQR), que abarca del primer cuartil (Q1) al tercer cuartil (Q3).\nLínea dentro de la caja: Indica la mediana de los datos.\nBigotes (whiskers): Extienden los valores hasta 1.5 veces el IQR desde los cuartiles Q1 y Q3.\nPuntos fuera de los bigotes: Representan valores atípicos (outliers), que están fuera del rango esperado.\n\n\n\n\n14.3.6 Gráfico de líneas\nLos gráficos de líneas son ideales para visualizar tendencias a lo largo del tiempo o en secuencias de datos ordenados. Este tipo de gráfico es especialmente útil para identificar patrones, como aumentos, disminuciones o fluctuaciones en los datos.\n\n14.3.6.1 Ejemplo práctico: Creación de un gráfico de líneas\nEl siguiente código muestra cómo crear un gráfico de líneas utilizando ggplot2 para visualizar la cantidad de estudiantes encuestados por año de ingreso:\n\n# Crear un gráfico de líneas de estudiantes por año de ingreso\nggplot(data = datos, aes(x = AÑO_ING)) +\n  geom_line(stat = \"count\", color = \"darkblue\", linewidth = 1.2) +\n  geom_point(stat = \"count\", color = \"darkred\", size = 3) +\n  labs(title = \"Estudiantes encuestados por año de ingreso\",\n       subtitle = \"Universidad de San Carlos de Guatemala (2002)\",\n       x = \"Año de ingreso\",\n       y = \"Número de estudiantes\") \n\n\n\n\n\n\n\n\nExplicación del código\n\nggplot(data = datos, aes(x = AÑO_ING)): Se define el conjunto de datos (datos) y se especifica la variable AÑO_ING como el eje X, que representa los años de ingreso de los estudiantes. En este caso, no se especifica una variable para el eje Y, ya que el conteo de estudiantes por año se calcula automáticamente con stat = \"count\".\ngeom_line(stat = “count”, color = “darkblue”, linewidth = 1.2): La función geom_line() genera la línea que conecta los puntos correspondientes al conteo de estudiantes por año.\nstat = \"count\" indica que se debe contar automáticamente el número de observaciones en cada categoría del eje X.\ncolor: Define el color de la línea (en este caso, azul oscuro).\nlinewidth: Ajusta el grosor de la línea (1.2 en este ejemplo).\ngeom_point(stat = “count”, color = “darkred”, size = 3): La función geom_point() añade puntos en cada categoría del eje X, representando el conteo de estudiantes.\nstat = \"count\" asegura que los puntos correspondan al conteo calculado.\ncolor: Define el color de los puntos (en este caso, rojo oscuro).\nsize: Ajusta el tamaño de los puntos (3 en este ejemplo).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "09.3_visualizacion.html#personalización-de-gráficos",
    "href": "09.3_visualizacion.html#personalización-de-gráficos",
    "title": "14  Visualización de datos con ggplot2",
    "section": "14.4 Personalización de gráficos",
    "text": "14.4 Personalización de gráficos\nLa personalización de gráficos en ggplot2 permite adaptarlos a diferentes necesidades, mejorando tanto su presentación como su capacidad para comunicar información de manera efectiva. A continuación, se describen algunas de las opciones más comunes, comenzando con la personalización de colores.\n\n14.4.1 Personalización de colores\nEn ggplot2, es posible modificar los colores de los elementos del gráfico, como puntos, barras o líneas, para destacar información clave o mejorar la estética general. Esto se puede lograr utilizando argumentos como color (para bordes o contornos) y fill (para colores de relleno).\n\n14.4.1.1 Personalización de colores en un gráfico de dispersión\nEl siguiente código muestra cómo personalizar el color de los puntos en un gráfico de dispersión:\n\n# Personalización de colores en un gráfico de dispersión\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point(color = \"darkgreen\", size = 2) +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\ncolor = \"darkgreen\" define el color de los puntos como verde oscuro.\nsize = 2 ajusta el tamaño de los puntos para mejorar su visibilidad.\n\n\n\n14.4.1.2 Personalización de colores por grupo\nSi se desea asignar colores diferentes a los puntos según una variable categórica, se puede incluir el argumento color dentro de aes():\n\n# Personalización de colores por grupo\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs, color = SEXO)) +\n  geom_point(size = 2) +\n  labs(title = \"Relación entre talla y peso por sexo\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\",\n       color = \"Sexo\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nLos puntos se colorean automáticamente según los valores de la variable SEXO.\nLa leyenda se genera de forma automática para indicar el significado de los colores.\n\n\n\n14.4.1.3 Personalización de colores en gráficos con relleno\nEn gráficos como barras o boxplots, se utiliza el argumento fill para personalizar el color de relleno:\n\n# Personalización de colores en gráficos con relleno\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)) +\n  geom_boxplot() +\n  labs(title = \"Distribución del peso por sexo\",\n       x = \"Sexo\",\n       y = \"Peso (libras)\",\n       fill = \"Sexo\")\n\n\n\n\n\n\n\n\nEn este ejemplo, las cajas del boxplot se rellenan con colores diferentes según la variable SEXO.\n\n\n14.4.1.4 Escalas de color personalizadas\nPara un mayor control sobre los colores, se pueden definir escalas personalizadas utilizando funciones como scale_color_manual() o scale_fill_manual():\n\n# Escalas de color personalizadas\nggplot(data = datos, aes(x = SEXO, y = PESO_lbs, fill = SEXO)) +\n  geom_boxplot() +\n  scale_fill_manual(values = c(  \"pink\", \"lightblue\")) +\n  labs(title = \"Distribución del peso por sexo\",\n       x = \"Sexo\",\n       y = \"Peso (libras)\",\n       fill = \"Sexo\")\n\n\n\n\n\n\n\n\nEn este ejemplo, se asignan colores específicos a cada categoría de la variable SEXO, R realiza la realiza la asignación de los colores de la escala en orden alfabético de las variables categóricas.\n\n\n\n14.4.2 Etiquetas y títulos\nEn ggplot2, es posible añadir y personalizar títulos, subtítulos y etiquetas de los ejes para mejorar la claridad y presentación de los gráficos. Estas etiquetas ayudan a contextualizar la información y a facilitar su interpretación.\n\n14.4.2.1 Personalización de títulos y etiquetas\nLa función labs() se utiliza para añadir y personalizar los siguientes elementos:\n\ntitle: Título principal del gráfico, que describe su propósito o contenido.\nsubtitle: Subtítulo que proporciona información adicional o contexto.\nx: Etiqueta del eje X, que describe la variable representada en este eje.\ny: Etiqueta del eje Y, que describe la variable representada en este eje.\ncaption (opcional): Texto adicional, como la fuente de los datos o notas aclaratorias.\n\n\n\n14.4.2.2 Añadir subtítulos y etiquetas personalizadas\nEl siguiente código muestra cómo personalizar títulos, subtítulos y etiquetas de los ejes en un gráfico de dispersión:\n\n# Añadir subtítulos y etiquetas personalizadas\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  labs(title = \"Relación entre talla y peso\",\n       subtitle = \"Datos del estudio de 2002\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\",\n       caption = \"Fuente: Base de datos de estudiantes\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\ntitle añade un título descriptivo al gráfico.\nsubtitle proporciona contexto adicional, como el año del estudio.\nx y y personalizan las etiquetas de los ejes, indicando las unidades de medida.\ncaption incluye una nota al pie con la fuente de los datos.\n\n\n\n14.4.2.3 Ajuste de la posición y estilo de los títulos\nSe puede personalizar la posición, tamaño y estilo de los títulos utilizando la función theme():\n\n# Ajuste de la posición y estilo de los títulos\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  labs(title = \"Relación entre talla y peso\",\n       subtitle = \"Datos del estudio de 2002\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\") +\n  theme(plot.title = element_text(hjust = 0.5, \n                                  size = 16, \n                                  face = \"bold\"),\n        plot.subtitle = element_text(hjust = 0.5, \n                                     size = 12, \n                                     face = \"italic\"))\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nhjust = 0.5 centra el título y el subtítulo.\nsize ajusta el tamaño del texto.\nface define el estilo del texto (\"bold\" para negrita, \"italic\" para cursiva).\n\n\n\n14.4.2.4 Rotación de etiquetas en los ejes\nSi las etiquetas del eje X son largas o numerosas, se pueden rotar para mejorar la legibilidad:\n\n# Rotación de etiquetas en los ejes\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\") +\n  theme(axis.text.y = element_text(angle = 90, hjust = 0.5))\n\n\n\n\n\n\n\n\nEn este ejemplo, las etiquetas del eje Y se rotan 90 grados.\n\n\n\n14.4.3 Temas\nEn ggplot2, los temas permiten modificar el estilo general de un gráfico, ajustando elementos como el fondo, las líneas de los ejes, las fuentes y la disposición de los textos. Esto facilita la creación de gráficos con un diseño coherente y adaptado a diferentes propósitos, como presentaciones, informes o publicaciones.\n\n14.4.3.1 Aplicación de temas predefinidos\nggplot2 incluye varios temas predefinidos que se pueden aplicar directamente para cambiar el estilo del gráfico. Algunos de los más comunes son:\n\ntheme_minimal(): Un diseño limpio y moderno, con un fondo blanco y líneas simples.\ntheme_classic(): Un estilo clásico con líneas de ejes visibles y sin cuadrícula.\ntheme_light(): Similar a theme_minimal(), pero con cuadrículas más visibles.\ntheme_dark(): Un diseño con fondo oscuro, ideal para presentaciones.\ntheme_void(): Un gráfico sin ejes ni cuadrículas, útil para gráficos personalizados.\n\n\n\n14.4.3.2 Ejemplo: Aplicar un tema minimalista\nEl siguiente código muestra cómo aplicar el tema theme_minimal() a un gráfico de dispersión:\n\n# Ejemplo: Aplicar un tema minimalista\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  theme_minimal()\n\n\n\n\n\n\n\n\nEn este ejemplo: theme_minimal() elimina elementos innecesarios, como bordes y fondos grises, dejando un diseño limpio y profesional.\n\n\n14.4.3.3 Ejemplo: personalización de temas\nAdemás de los temas predefinidos, es posible personalizar elementos específicos del gráfico utilizando la función theme(). Por ejemplo:\n\n# Personalización de temas\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 16, face = \"bold\"),\n    axis.text = element_text(size = 12),\n    axis.title = element_text(size = 14, face = \"italic\"),\n    panel.grid.major = element_line(color = \"gray\", linetype = \"dashed\")\n  ) +\n  labs(title = \"Relación entre talla y peso\",\n       x = \"Talla (metros)\",\n       y = \"Peso (libras)\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nplot.title centra el título y ajusta su tamaño y estilo.\naxis.text y axis.title modifican el tamaño y estilo de las etiquetas de los ejes.\npanel.grid.major personaliza las líneas de la cuadrícula principal, cambiando su color y estilo.\n\n\n\n\n14.4.4 Facetas\nLas facetas en ggplot2 permiten dividir un gráfico en múltiples subgráficos basados en los valores de una variable categórica. Esto es especialmente útil para comparar patrones o relaciones entre diferentes grupos dentro de un conjunto de datos, manteniendo la coherencia visual.\n\n14.4.4.1 Ejemplo: relación entre talla y peso por facultad\nEl siguiente código muestra cómo utilizar facetas para analizar la relación entre talla y peso, separando los datos por facultad:\n\n# Ejemplo: relación entre talla y peso por facultad\nggplot(data = datos, aes(x = TALLA, y = PESO_lbs)) +\n  geom_point() +\n  facet_wrap(~ FACULTAD) +\n  labs(title = \"Relación entre talla y peso por facultad\")\n\n\n\n\n\n\n\n\nEn este ejemplo:\n\nfacet_wrap(~ FACULTAD) divide el gráfico en subgráficos, uno para cada valor único de la variable FACULTAD.\nCada subgráfico muestra la relación entre TALLA y PESO_lbs para una facultad específica.\n\n\n\n\n14.4.5 Ejemplo avanzado de personalización\nLa flexibilidad y la lógica de capas de ggplot2 permiten crear gráficos con un alto grado de personalización, adaptados a necesidades específicas y con un diseño profesional. A continuación, se presenta un ejemplo de un gráfico de barras con personalización detallada:\n\n# Ejemplo avanzado de personalización\nggplot(data = datos, aes(x = FACULTAD)) +\n  geom_bar(fill = \"steelblue\", color = \"black\", alpha = 0.8) +\n  labs(\n    title = \"Distribución de estudiantes por facultad\",\n    subtitle = \"Datos del estudio de 2002, USAC\",\n    x = \"Facultad\",\n    y = \"Cantidad de estudiantes\",\n    caption = \"Fuente: Estudio realizado en 2002\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 12, hjust = 0.5, color = \"gray50\"),\n    axis.title = element_text(size = 12, face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.caption = element_text(hjust = 0, size = 8, color = \"gray50\")\n  )\n\n\n\n\n\n\n\n\n\n14.4.5.1 Explicación del código\n\nDatos y mapeo estético: aes(x = FACULTAD): Se utiliza la variable FACULTAD directamente desde la base de datos para el eje X.\nGráfico de barras: geom_bar(): Genera automáticamente las barras basándose en la frecuencia de cada categoría. En el ejemplo se utilizaron los siguientes argumentos:\nfill = \"steelblue\": Define el color de relleno de las barras como azul acero.\ncolor = \"black\": Establece el color de los bordes de las barras en negro.\nalpha = 0.8: Ajusta la transparencia de las barras, permitiendo un diseño más suave.\nEtiquetas y títulos: labs(): Añade un título principal, subtítulo, etiquetas para los ejes y una nota al pie con la fuente de los datos.\nTema profesional: theme_minimal(): Aplica un diseño limpio y moderno.\nPersonalización específica: theme(): Personaliza elementos específicos del gráfico empleando los siguiente argumentos:\nplot.title: Ajusta el tamaño, estilo (negrita) y posición (centrado) del título.\nplot.subtitle: Cambia el tamaño, posición y color del subtítulo.\naxis.title: Modifica el tamaño y estilo de las etiquetas de los ejes.\naxis.text.x: Rota las etiquetas del eje X 45 grados para mejorar la legibilidad, especialmente si las categorías tienen nombres largos.\npanel.grid.major.x y panel.grid.minor: Elimina las líneas de cuadrícula verticales y menores para un diseño más limpio.\nplot.caption: Ajusta el tamaño, posición y color de la nota al pie.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Visualización de datos con ggplot2</span>"
    ]
  },
  {
    "objectID": "10.1_exportacion.html",
    "href": "10.1_exportacion.html",
    "title": "15  Introducción a la Gestión de Proyectos en R",
    "section": "",
    "text": "15.1 Notas:\nEn esta sección se deberá abordar los conceptos clave como github y conceptos de exportación de resultados de análisis y se ampliara la sección de organización de proyectos y recomendaciones al gestionarlos en el formato de carpetas y subcarpetas, hay que revisar la sección inicial donde se hace una introducción a estos temas para evitar ser redundante por lo que hay que desarrollar ambas secciones de la mano.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Introducción a la Gestión de Proyectos en R</span>"
    ]
  },
  {
    "objectID": "10.2_exportacion.html",
    "href": "10.2_exportacion.html",
    "title": "16  Exportación de Resultados de Análisis en R",
    "section": "",
    "text": "16.1 La función ggsave()\nLa exportación de resultados es una etapa crucial en el análisis de datos, ya que permite guardar gráficos y tablas para su uso en informes, presentaciones o análisis posteriores. En esta sección, se detalla cómo guardar gráficos en formatos PNG y PDF utilizando la función ggsave() del paquete ggplot2, y cómo exportar tablas en formatos CSV y Excel utilizando las funciones write.csv() y write_xlsx() del paquete writexl. Estas herramientas son esenciales para garantizar que los resultados del análisis sean accesibles y reutilizables (R Core Team, 2023; Wickham, 2016).\nLa función ggsave() pertenece al paquete ggplot2 y se utiliza para guardar gráficos en diferentes formatos de archivo, como PNG, PDF, JPEG, entre otros. Es una herramienta versátil que permite personalizar aspectos como el tamaño, la resolución y el formato del archivo de salida (Wickham, 2016).\nLa sintaxis general de la función es la siguiente:\nggsave(\n  filename,\n  plot = last_plot(),\n  device = NULL,\n  path = NULL,\n  scale = 1,\n  width = NA,\n  height = NA,\n  units = c(\"in\", \"cm\", \"mm\"),\n  dpi = 300,\n  limitsize = TRUE)\nDescripción de los argumentos principales:\n1. filename: Este argumento es obligatorio y define el nombre del archivo de salida, incluyendo su extensión (por ejemplo, \"grafico.png\" o \"grafico.pdf\"). La extensión del archivo determina automáticamente el formato en el que se guardará el gráfico, a menos que se especifique explícitamente con el argumento device. Es importante asegurarse de que el nombre del archivo sea válido para el sistema operativo utilizado.\n2. plot: Este argumento opcional permite especificar el gráfico que se desea guardar. Si no se proporciona, ggsave() guardará automáticamente el último gráfico creado en la sesión de R, utilizando la función last_plot(). Esto es útil para flujos de trabajo interactivos, pero en proyectos más complejos se recomienda asignar los gráficos a objetos para evitar confusiones.\n3. device: El argumento device define el tipo de dispositivo o formato del archivo de salida, como \"png\", \"pdf\", \"jpeg\", entre otros. Si no se especifica, el formato se deduce automáticamente a partir de la extensión del archivo en filename. Este argumento es útil cuando se desea guardar un archivo con un formato específico, independientemente de la extensión.\n4. path: Este argumento opcional permite especificar el directorio donde se guardará el archivo. Si no se proporciona, el archivo se guardará en el directorio de trabajo actual. Es especialmente útil para organizar los gráficos en carpetas específicas dentro de un proyecto.\n5. scale: El argumento scale ajusta el tamaño del gráfico multiplicando las dimensiones especificadas en width y height por el valor proporcionado. Por defecto, su valor es 1, lo que significa que no se aplica escalado. Un valor mayor que 1 aumenta el tamaño del gráfico, mientras que un valor menor lo reduce.\n6. width y height: Estos argumentos definen el ancho y la altura del gráfico en las unidades especificadas por el argumento units. Si no se proporcionan, se utilizan las dimensiones predeterminadas del gráfico. Es importante ajustar estas dimensiones para garantizar que el gráfico se adapte correctamente al formato de salida.\n7. units: El argumento units especifica las unidades de medida para width y height. Los valores posibles son \"in\" (pulgadas), \"cm\" (centímetros) y \"mm\" (milímetros). Por defecto, se utilizan pulgadas (\"in\"), pero se pueden cambiar según las necesidades del proyecto.\n8. dpi: El argumento dpi (dots per inch) define la resolución del gráfico, siendo relevante para formatos rasterizados como PNG, JPEG o TIFF. Su valor predeterminado es 300, adecuado para impresión. Para gráficos destinados a la web, se puede utilizar un valor menor, como 72.\n9. limitsize: Este argumento controla si se permite guardar gráficos con dimensiones excesivamente grandes (mayores a 50 pulgadas). Si se establece en TRUE (valor predeterminado), se genera un error al intentar guardar gráficos grandes. Para desactivar esta restricción, se debe establecer en FALSE.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Exportación de Resultados de Análisis en R</span>"
    ]
  },
  {
    "objectID": "10.2_exportacion.html#guardar-en-formatos-pdf-y-png",
    "href": "10.2_exportacion.html#guardar-en-formatos-pdf-y-png",
    "title": "16  Exportación de Resultados de Análisis en R",
    "section": "16.2 Guardar en formatos PDF y PNG",
    "text": "16.2 Guardar en formatos PDF y PNG\nSi no se especifica el argumento plot, la función ggsave() guardará automáticamente el último gráfico creado en la sesión de R. Esto es útil cuando se trabaja de manera interactiva y se desea guardar rápidamente un gráfico sin asignarlo a un objeto. A continuación, se describen los pasos para exportar gráficos en formatos PNG y PDF, junto con un ejemplo.\n\n16.2.1 Crear un gráfico con ggplot2\nAntes de guardar un gráfico, es necesario crearlo. A continuación, se presenta un ejemplo de un gráfico creado con ggplot2:\n\n# Instalación y carga de paquetes esenciales\n\n# Paquete que incluye ggplot2, dplyr, tidyr\nif (!require(\"tidyverse\")) install.packages(\"tidyverse\")\n\n# Importar la base de datos\ndatos &lt;- read_csv(\"datos_estudiantes.csv\")\n\n# Ejemplo avanzado de personalización de un gráfico\nplot&lt;- ggplot(data = datos, aes(x = FACULTAD)) +\n  geom_bar(fill = \"steelblue\", color = \"black\", alpha = 0.8) +\n  labs(\n    title = \"Distribución de estudiantes por facultad\",\n    subtitle = \"Datos del estudio de 2002, \n    Universidad de San Carlos de Guatemala\",\n    x = \"Facultad\",\n    y = \"Cantidad de estudiantes\",\n    caption = \"Fuente: Estudio realizado en 2002\"\n  ) +\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 12, hjust = 0.5, color = \"gray50\"),\n    axis.title = element_text(size = 12, face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor = element_blank(),\n    plot.caption = element_text(hjust = 0, size = 8, color = \"gray50\")\n  )\n\n\n\n16.2.2 Guardar el gráfico en formato PNG\nUna vez creado el gráfico, se puede guardar utilizando ggsave():\n\n# Guardar el gráfico en formato PNG\nggsave(\"grafico.png\", width = 8, height = 6, dpi = 300)\n\n\nfilename: Nombre del archivo de salida (en este caso, \"grafico.png\").\nplot: Objeto del gráfico que se desea guardar.\nwidth y height: Dimensiones del gráfico en pulgadas.\ndpi: Resolución del archivo en puntos por pulgada (300 dpi es adecuado para impresión).\n\n\n\n16.2.3 Guardar en Formato PDF\nEl formato PDF es ideal para gráficos que requieren escalado sin pérdida de calidad, como en publicaciones científicas o informes.\n\n# Guardar el gráfico en formato PDF\nggsave(\"grafico.pdf\", width = 8, height = 6)\n\nDiferencias con PNG: No es necesario especificar la resolución (dpi), ya que el formato PDF es vectorial y no depende de la resolución.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Exportación de Resultados de Análisis en R</span>"
    ]
  },
  {
    "objectID": "10.2_exportacion.html#guardar-tablas-en-csv-y-excel",
    "href": "10.2_exportacion.html#guardar-tablas-en-csv-y-excel",
    "title": "16  Exportación de Resultados de Análisis en R",
    "section": "16.3 Guardar Tablas en CSV y Excel",
    "text": "16.3 Guardar Tablas en CSV y Excel\nLa exportación de tablas es esencial para compartir datos o realizar análisis adicionales en otras herramientas. A continuación, se detalla cómo guardar tablas en formatos CSV y Excel.\n\n16.3.1 Crear un data frame de ejemplo\nSe puede utilizar un data frame de ejemplo para ilustrar el proceso:\n\n# Crear un data frame de ejemplo\nejemplo &lt;- data.frame(\n  Nombre = c(\"Ana\", \"Luis\", \"María\"),\n  Edad = c(25, 30, 22),\n  Ciudad = c(\"Madrid\", \"Barcelona\", \"Valencia\")\n)\n\n\n\n16.3.2 Guardar la tabla en formato CSV\nUtilizando la función write.csv(), se puede exportar el data frame:\n\n# Guardar la tabla en formato CSV\nwrite.csv(ejemplo, \"ejemplo.csv\", row.names = FALSE)\n\nParámetros importantes:\nfile: Nombre del archivo de salida (en este caso, \"tabla.csv\").\nrow.names: Si se establece en FALSE, no se incluirán los índices de las filas como una columna adicional.\n\n\n16.3.3 Guardar en Formato Excel\nPara exportar datos a Excel, se utiliza el paquete writexl, por lo que primero hay que instalar y cargar el paquete:\n\n# Paquete para la exportación de datos a Excel\nif (!require(\"writexl\")) install.packages(\"writexl\")\n\nDespues de haber cargado el paquete utilizando la función write_xlsx(), se puede exportar el data frame:\n\n# Guardar la tabla en formato Excel\nwrite_xlsx(ejemplo, \"ejemplo.xlsx\")\n\nParámetros importantes:\n\nobjeto: Nombre del dataframe o lista que se quiere exportar en formato Excel.\npath: Nombre del archivo de salida (en este caso, \"ejemplo.xlsx\").\n\nResultado: El archivo ejemplo.xlsx se guardará en el directorio de trabajo actual, listo para ser abierto en Microsoft Excel o software similar.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Exportación de Resultados de Análisis en R</span>"
    ]
  },
  {
    "objectID": "10.2_exportacion.html#comparación-de-formatos",
    "href": "10.2_exportacion.html#comparación-de-formatos",
    "title": "16  Exportación de Resultados de Análisis en R",
    "section": "16.4 Comparación de Formatos",
    "text": "16.4 Comparación de Formatos\n\n\n\n\n\n\n\n\n\nFormato\nUso Principal\nVentajas\nDesventajas\n\n\n\n\nPNG\nPresentaciones y documentos digitales\nAlta calidad, ampliamente compatible\nNo escalable sin pérdida de calidad\n\n\nPDF\nPublicaciones científicas e informes\nEscalable, ideal para impresión\nMenos compatible con editores básicos\n\n\nCSV\nAnálisis de datos en herramientas simples\nLigero, compatible con múltiples plataformas\nNo admite formatos complejos\n\n\nExcel\nCompartir datos estructurados\nCompatible con herramientas avanzadas\nRequiere software específico",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Exportación de Resultados de Análisis en R</span>"
    ]
  },
  {
    "objectID": "10.3_exportacion.html",
    "href": "10.3_exportacion.html",
    "title": "17  Uso de Git y GitHub en Proyectos de R",
    "section": "",
    "text": "17.1 Notas:\nEn esta sección se abordará una explicación sobre como clonar un repositorio de github en nuestro ordenador y como tener un control de versiones de nuestros proyectos usando github ademas de hablar de los pros y contras.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Uso de Git y GitHub en Proyectos de R</span>"
    ]
  },
  {
    "objectID": "regresion_multiple.html",
    "href": "regresion_multiple.html",
    "title": "22  Regresión múltiple usando R",
    "section": "",
    "text": "22.1 Notas:\nEn esta sección se desarrollará un ejemplo de regresión multiple\nEsta pendiente de finalización y carga",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Regresión múltiple usando R</span>"
    ]
  }
]