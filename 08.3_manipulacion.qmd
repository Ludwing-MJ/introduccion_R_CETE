# Manipulación de datos con dplyr y tidyr

```{r message=FALSE, warning=FALSE, echo=FALSE}
# Instalar y cargar el tidyverse
if (!require("tidyverse")) install.packages("tidyverse")
```

## Introducción a los paquetes dplyr y tidyr

Los paquetes dplyr y tidyr forman parte del ecosistema tidyverse y han sido diseñados específicamente para la manipulación y transformación de datos en R. En el contexto del análisis estadístico clásico, estas herramientas facilitan la preparación de datos para técnicas como ANOVA, regresión y pruebas de hipótesis, ofreciendo una sintaxis clara y consistente (Wickham & Grolemund, 2017).

El paquete dplyr se especializa en la manipulación de datos tabulares, proporcionando funciones específicas para operaciones comunes como filtrado, selección y agregación. Por su parte, tidyr se centra en la reorganización de datos, permitiendo transformaciones entre diferentes formatos según los requerimientos del análisis estadístico (Wickham et al., 2023).

Para ilustrar el uso de estas herramientas, en esta sección se desarrollará un ejemplo práctico que permitirá explorar las principales funciones de manipulación de datos. El script correspondiente a este ejemplo está disponible en el siguiente repositorio: [Repositorio de ejemplo - Manipulación de datos](https://github.com/Ludwing-MJ/Manipulacion_Ej).

## Datos ejemplo

Se emplea el mismo conjunto de datos simulado del experimento agrícola utilizado en el capítulo anterior, lo que permite comparar directamente los enfoques de R base y tidyverse.

```{r message=FALSE, warning=FALSE}
# Cargar el paquete necesario
library(dplyr)
library(tidyr)

# Crear datos de ejemplo
set.seed(123) # Para reproducibilidad

datos_cultivo <- data.frame(
  parcela = 1:20,
  tratamiento = rep(c("Control", "Fertilizante A",
                      "Fertilizante B", "Fertilizante C"), each = 5),
  bloque = rep(1:5, times = 4),
  altura_cm = round(rnorm(20, mean = 65, sd = 10), 1),
  peso_gr = round(rnorm(20, mean = 120, sd = 25), 1),
  daño_plaga = sample(c("Alto", "Medio", "Bajo"), 20, replace = TRUE),
  fecha_siembra = as.Date("2024-01-01") + sample(1:10, 20, replace = TRUE)
)

# Agregar algunos valores NA para ejemplos posteriores
datos_cultivo$altura_cm[c(3, 15)] <- NA
datos_cultivo$peso_gr[c(7, 18)] <- NA
```

## Operaciones básicas con dplyr

### Filtrado de datos con filter()

La función `filter()` permite seleccionar filas de un data frame que cumplen condiciones lógicas. Su sintaxis es:

```{r eval=FALSE}
filter(.data, ...)
```

1.  `.data`: el data frame o tibble sobre el que se aplicará el filtrado.

2.  `...`: una o más condiciones lógicas que deben cumplirse para que una fila sea seleccionada.

Ejemplo:

```{r message=FALSE, warning=FALSE}
# Filtrar las parcelas con tratamiento "Control"
datos_control <- filter(datos_cultivo, tratamiento == "Control")
head(datos_control) # Visualizar el resultado

# Filtrar parcelas con altura mayor a 65 cm y tratamiento distinto de "Control"
datos_altos <- filter(datos_cultivo, altura_cm > 65, tratamiento != "Control")
head(datos_altos)   # Visualizar el resultado

```

En el primer caso, solo se seleccionan las filas donde la columna `tratamiento` es igual a "Control". En el segundo, se seleccionan las filas donde la altura es mayor a 65 cm y el tratamiento no es "Control". Es importante notar que, a diferencia de R base, no es necesario escribir el nombre del data frame en cada condición, lo que simplifica la sintaxis (Wickham & Grolemund, 2017).

### Selección de columnas con select()

La función `select()` permite extraer columnas específicas de un data frame. Su sintaxis es:

```{r eval=FALSE}
select(.data, ...)
```

1.  `.data`: el data frame o tibble de entrada.

2.  `...`: nombres de las columnas a seleccionar, o funciones auxiliares como `starts_with()`, `ends_with()`, `contains()`, etc.

Ejemplo:

```{r}
# Seleccionar las columnas altura_cm y peso_gr
datos_mediciones <- select(datos_cultivo, altura_cm, peso_gr)
head(datos_mediciones)  # Visualizar el resultado
# Excluir la columna fecha_siembra
datos_sin_fecha <- select(datos_cultivo, -fecha_siembra)
head(datos_sin_fecha)  # Visualizar el resultado
# Seleccionar columnas que terminan en "cm" o "gr"
datos_numericos <- select(datos_cultivo, ends_with("cm"), ends_with("gr"))
head(datos_numericos)  # Visualizar el resultado


```

El uso de funciones auxiliares permite seleccionar columnas de manera flexible, lo que resulta útil en bases de datos extensas (Wickham et al., 2023).

### Creación y transformación de variables con mutate()

La función `mutate()` permite crear nuevas columnas o modificar las existentes. Su sintaxis es:

```{r eval=FALSE}
mutate(.data, ...)
```

1.  `.data`: el data frame o tibble de entrada.

2.  `...`: una o más expresiones que definen las nuevas columnas o transformaciones.

Ejemplo:

```{r}
# Crear una nueva variable: índice de crecimiento
datos_cultivo <- mutate(datos_cultivo,
                       indice_crecimiento = 
                         altura_cm / peso_gr)

# Crear varias variables nuevas
datos_cultivo <- mutate(datos_cultivo,
                       altura_m = altura_cm / 100,
                       peso_kg = peso_gr / 1000,
                       categoria_altura = ifelse(
                         altura_cm > 65, "Alto", "Bajo"))

```

La función `ifelse(condición, valor_si_verdadero, valor_si_falso)` permite crear variables categóricas a partir de condiciones lógicas, lo que es común en la estadística clásica para definir grupos o categorías (Wickham & Grolemund, 2017).

### Agrupamiento y resumen con group_by() y summarize()

La función `group_by()` agrupa los datos según una o más variables, y `summarize()` calcula estadísticas resumen por grupo. Sus sintaxis son:

```{r eval=FALSE}
group_by(.data, ...)
summarize(.data, ...)
```

1.  `.data`: el data frame o tibble de entrada.

2.  `...`: variables de agrupamiento (en `group_by`) o expresiones de resumen (en `summarize`).

Ejemplo:

```{r}
# Agrupar por tratamiento y calcular estadísticas descriptivas
resumen_tratamiento <- datos_cultivo %>%
  group_by(tratamiento) %>%
  summarize(
    media_altura = mean(altura_cm, na.rm = TRUE),
    sd_altura = sd(altura_cm, na.rm = TRUE),
    n = n()
  )
resumen_tratamiento
```

1.  `mean(altura_cm, na.rm = TRUE)`: calcula la media, ignorando los valores NA.

2.  `sd(altura_cm, na.rm = TRUE)`: calcula la desviación estándar.

3.  `n()`: cuenta el número de observaciones en cada grupo.

Estas funciones son esenciales para obtener resúmenes estadísticos por grupo, como promedios por tratamiento en un experimento clásico (Wickham et al., 2023).

### Ordenamiento de datos con arrange()

La función `arrange()` permite ordenar los datos según una o más variables. Su sintaxis es:

```{r eval=FALSE}
arrange(.data, ...)
```

1.  `.data`: el data frame o tibble de entrada.

2.  `...`: variables por las que se desea ordenar; se puede usar `desc()` para orden descendente.

Ejemplo:

```{r}
# Ordenar por altura de menor a mayor
datos_ordenados <- arrange(datos_cultivo, altura_cm)
# Ordenar por tratamiento y peso descendente
datos_ordenados_multi <- arrange(datos_cultivo, 
                                 tratamiento, 
                                 desc(peso_gr))
```

El ordenamiento es útil para identificar valores extremos o preparar tablas para reportes (Wickham & Grolemund, 2017).

## Introducción a los pipes (%\>%)

El operador pipe (`%>%`), introducido por el paquete magrittr y adoptado como parte fundamental del tidyverse, representa una innovación significativa en la sintaxis de R. Este operador permite construir secuencias de operaciones de manera clara y lógica, siguiendo un flujo natural de procesamiento de datos. El pipe toma el resultado de una expresión a su izquierda y lo pasa como primer argumento a la función a su derecha (Wickham & Grolemund, 2017).

La sintaxis básica del operador pipe es:

```{r eval=FALSE}
# Estructura usando pipes
datos %>% funcion()
# Equivalente a la siguiente estructura anidada
funcion(datos)
```

### Ventajas del uso de pipes

El uso de pipes ofrece múltiples ventajas en el análisis estadístico (Wickham et al., 2023):

1.  **Legibilidad mejorada**: Las operaciones se leen de izquierda a derecha y de arriba hacia abajo, siguiendo el orden natural de lectura.

2.  **Reducción de objetos intermedios**: No es necesario crear variables temporales para almacenar resultados intermedios.

3.  **Facilidad de depuración**: Cada paso puede ser comentado o modificado independientemente.

4.  **Claridad en la secuencia de operaciones**: El flujo de trabajo se hace explícito y fácil de seguir.

### Ejemplo práctico

Sin pipe (anidado): En la sintaxis tradicional, las funciones deben anidarse, lo que puede dificultar la lectura:

```{r}
# Calcular la media de altura por tratamiento, excluyendo valores NA
resumen_tratamiento <- summarize(
  group_by(
    filter(datos_cultivo, !is.na(altura_cm)),
    tratamiento
  ),
  media_altura = mean(altura_cm)
)
```

En este ejemplo, primero se filtran las filas sin valores faltantes en `altura_cm`, luego se agrupan por `tratamiento` y finalmente se calcula la media de altura para cada grupo.

Con pipe (más legible) el mismo análisis, usando pipes, resulta más claro y fácil de seguir:

```{r}
# Calcular la media de altura por tratamiento, excluyendo valores NA
resumen_tratamiento <- datos_cultivo %>%
  # 1. Eliminar filas con NA en altura_cm
  filter(!is.na(altura_cm)) %>%      
  # 2. Agrupar los datos por tratamiento
  group_by(tratamiento) %>%         
  # 3. Calcular la media de altura por grupo
  summarize(media_altura = mean(altura_cm)) 
```

1.  En la primera línea, se eliminan las filas donde la altura es NA.

2.  En la segunda línea, se agrupan los datos por el tipo de tratamiento.

3.  En la tercera línea, se calcula la media de la altura para cada tratamiento.

Cada paso es explícito y se puede leer de arriba hacia abajo, lo que facilita la comprensión y depuración del análisis (Wickham & Grolemund, 2017).

## Transformaciones de datos con tidyr

El paquete tidyr es una herramienta fundamental para la reorganización y transformación de datos en R, permitiendo adaptar la estructura de los conjuntos de datos a los requerimientos de los métodos estadísticos clásicos. Estas transformaciones son esenciales para preparar los datos antes de aplicar técnicas como ANOVA, regresión o análisis descriptivos, ya que muchos procedimientos requieren que los datos estén en un formato específico (Wickham & Grolemund, 2017).

### Transformación de formato ancho a largo con pivot_longer()

La función `pivot_longer()` convierte varias columnas de un data frame en pares de nombre-valor, generando un formato largo. Este formato es especialmente útil en análisis estadísticos donde cada observación debe ocupar una fila y las variables medidas se representan en una columna adicional, como en el caso de ANOVA de medidas repetidas (Wickham & Grolemund, 2017).

La sintaxis principal de `pivot_longer()` es la siguiente:

```{r eval=FALSE}
pivot_longer(
  data,         # Data frame o tibble de entrada
  cols,         # Columnas a transformar (vector de nombres, rango o función selectora)
  names_to,     # Nombre de la nueva columna que contendrá los nombres originales de las variables
  values_to     # Nombre de la nueva columna que contendrá los valores
)
```

Por ejemplo, considérese un subconjunto pequeño de datos con alturas y pesos de tres parcelas:

```{r}
library(tidyr)
# Crear un dataframe para visualizar mejor los ejemplos
mini_datos <- data.frame(
  parcela = c(1, 2, 3),
  altura_cm = c(70, 65, 60),
  peso_gr = c(120, 115, 110)
)
mini_datos # visualizar el data frame original
```

Para transformar este data frame a formato largo, se utiliza:

```{r}
mini_largo <- pivot_longer(
  data = mini_datos,
  cols = c(altura_cm, peso_gr), # Columnas a transformar
  names_to = "variable",        # Nueva columna para los nombres de las variables originales
  values_to = "valor"           # Nueva columna para los valores
)
mini_largo # Visualizar el resultado
```

En este ejemplo, el argumento `cols` indica las columnas a transformar, `names_to` define el nombre de la columna que almacenará los nombres de las variables originales y `values_to` define el nombre de la columna que almacenará los valores correspondientes (Wickham & Grolemund, 2017).

### Transformación de formato largo a ancho con pivot_wider()

La función `pivot_wider()` realiza la transformación inversa, es decir, convierte un data frame en formato largo a formato ancho. Esto es útil para reportes o análisis que requieren que cada variable esté en una columna separada (Wickham & Grolemund, 2017).

La sintaxis principal de `pivot_wider()` es:

```{r eval=FALSE}
pivot_wider(
  data,         # Data frame o tibble de entrada
  names_from,   # Columna cuyos valores se usarán como nombres de nuevas columnas
  values_from   # Columna cuyos valores se distribuirán en las nuevas columnas
)
```

Utilizando el subconjunto `mini_largo` generado previamente:

```{r}
mini_ancho <- pivot_wider(
  data = mini_largo,
  names_from = variable,  # Columna que define los nombres de las nuevas columnas
  values_from = valor     # Columna que define los valores a distribuir
)
mini_ancho # Visualizar el resultado
```

En este caso, el argumento `names_from` indica la columna cuyos valores se convertirán en nombres de nuevas columnas y `values_from` indica la columna cuyos valores se colocarán en las nuevas columnas (Wickham & Grolemund, 2017).

### Manipulación de variables compuestas con separate() y unite()

En ocasiones, una columna puede contener información de varias variables codificadas en un solo valor. Para dividir o combinar estas variables, se utilizan las funciones `separate()` y `unite()` (Wickham & Grolemund, 2017).

La función `separate()` divide una columna en dos o más columnas, utilizando un carácter separador. Su sintaxis principal es:

```{r eval=FALSE}
separate(
  data,         # Data frame o tibble de entrada
  col,          # Columna a dividir
  into,         # Vector con los nombres de las nuevas columnas
  sep           # Carácter separador (por defecto, cualquier carácter no alfanumérico)
)
```

Por ejemplo, considérese el siguiente subconjunto:

```{r}
# Crear el dataframe para el ejemplo
mini_datos_comp <- data.frame(
  parcela_bloque = c("1-1", "2-2", "3-3"),
  altura_cm = c(70, 65, 60)
)
# Visualizar el dataframe original
mini_datos_comp
```

Para separar la columna `parcela_bloque` en dos columnas llamadas `parcela` y `bloque`, se utiliza:

```{r}
mini_separado <- separate(
  data = mini_datos_comp,
  col = parcela_bloque,         # Columna a dividir
  into = c("parcela", "bloque"),# Nombres de las nuevas columnas
  sep = "-"                     # Carácter separador
)
mini_separado # Visualizar el resultado
```

El argumento `col` indica la columna a dividir, `into` define los nombres de las nuevas columnas y `sep` especifica el carácter separador (Wickham & Grolemund, 2017).

La función `unite()` combina dos o más columnas en una sola, utilizando un carácter separador. Su sintaxis principal es:

```{r eval=FALSE}
unite(
  data,         # Data frame o tibble de entrada
  col,          # Nombre de la nueva columna
  ...,          # Columnas a unir
  sep           # Carácter separador
)
```

Por ejemplo, para volver a unir las columnas `parcela` y `bloque` en una sola columna `parcela_bloque`:

```{r}
mini_unido <- unite(
  data = mini_separado,
  col = "parcela_bloque", # Nombre de la nueva columna
  parcela, bloque,        # Columnas a unir
  sep = "-"               # Carácter separador
)
mini_unido # Visualizar el resultado
```

El argumento `col` define el nombre de la nueva columna resultante, los siguientes argumentos son las columnas a unir y `sep` indica el carácter separador (Wickham & Grolemund, 2017).

## Ejemplo integrado: Preparación de datos para análisis estadístico clásico

A continuación se muestra un flujo de trabajo típico para preparar los datos del experimento agrícola antes de realizar un análisis de varianza (ANOVA), utilizando dplyr y tidyr.

```{r}
# 1. Eliminar valores faltantes en altura y peso
datos_limpios <- datos_cultivo %>%
  filter(!is.na(altura_cm), !is.na(peso_gr))

# 2. Crear variables derivadas
datos_limpios <- datos_limpios %>%
  mutate(
    indice_crecimiento = altura_cm / peso_gr,
    categoria_altura = ifelse(altura_cm > 65, "Alto", "Bajo")
  )

# 3. Agrupar por tratamiento y calcular estadísticas descriptivas
resumen_tratamiento <- datos_limpios %>%
  group_by(tratamiento) %>%
  summarize(
    media_altura = mean(altura_cm),
    sd_altura = sd(altura_cm),
    n = n()
  )
resumen_tratamiento
# 4. Transformar a formato largo para análisis multivariado
datos_largo <- datos_limpios %>%
  pivot_longer(
    cols = c(altura_cm, peso_gr),
    names_to = "variable",
    values_to = "valor"
  )
head(datos_largo)
```

## Comparación entre la manipulación de datos con R base y tidyverse

La manipulación de datos es una etapa fundamental en el análisis estadístico clásico. Existen dos enfoques principales en R: el uso de funciones base y el uso de paquetes del tidyverse, como dplyr y tidyr. A continuación se presenta un cuadro comparativo que resume las principales diferencias entre ambos enfoques, considerando aspectos como sintaxis, legibilidad, flexibilidad y reproducibilidad (Wickham & Grolemund, 2017).

| Aspecto | R base | tidyverse (dplyr/tidyr) |
|----|----|----|
| **Sintaxis** | Uso de corchetes, funciones como `subset()`, `apply()`, y anidación. | Uso de funciones verbales (`filter()`, `select()`, `mutate()`, etc.) y pipes `%>%`. |
| **Legibilidad** | El código puede ser difícil de leer, especialmente con operaciones anidadas. | El flujo de trabajo es secuencial y fácil de seguir, cada paso en una línea. |
| **Creación de variables** | Se usa `$` o `transform()`. | Se usa `mutate()`, que permite crear o modificar variables de forma clara. |
| **Filtrado de filas** | Se usan corchetes o `subset()`. | Se usa `filter()`, con sintaxis más intuitiva y sin necesidad de repetir el nombre del data frame. |
| **Selección de columnas** | Se usan corchetes o `select()`. | Se usa `select()`, con funciones auxiliares como `starts_with()`, `ends_with()`. |
| **Agrupamiento y resumen** | Se usan `tapply()`, `aggregate()`, o bucles. | Se usan `group_by()` y `summarize()`, facilitando el cálculo de estadísticas por grupo. |
| **Transformación de formato** | Se usan funciones como `reshape()`, `melt()`, `cast()`. | Se usan `pivot_longer()` y `pivot_wider()`, con sintaxis más clara y moderna. |
| **Manejo de variables compuestas** | Se requiere manipulación manual con funciones como `strsplit()`. | Se usan `separate()` y `unite()`, que simplifican la división y combinación de columnas. |
| **Reproducibilidad** | El código puede ser menos reproducible y más propenso a errores. | El uso de pipes y funciones verbales mejora la reproducibilidad y la claridad del análisis. |
| **Curva de aprendizaje** | Familiar para usuarios con experiencia previa en R, pero puede ser menos intuitivo para principiantes. | Más accesible para principiantes, especialmente por la coherencia y claridad de la sintaxis. |

Como se observa, el enfoque tidyverse ofrece ventajas notables en términos de claridad, reproducibilidad y facilidad de uso, especialmente en flujos de trabajo complejos o colaborativos. No obstante, el conocimiento de las funciones base de R sigue siendo valioso, ya que permite comprender el funcionamiento interno del lenguaje y resolver tareas específicas de manera eficiente (Wickham & Grolemund, 2017).
